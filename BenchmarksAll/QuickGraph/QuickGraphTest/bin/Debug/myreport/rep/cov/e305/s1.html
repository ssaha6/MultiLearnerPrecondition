<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html>
<!-- saved from url=(0033)http://research.microsoft.com/pex -->
<head><link rel="StyleSheet" href="..\..\er.common.css" type="text/css" /><script src="..\..\er.common.js" type="text/javascript"> </script><link rel="SHORTCUT ICON" href="favicon.ico" /><link rel="icon" href="favicon.ico" type="image/x-icon" /><title>d:\experimental3\BenchmarksAll\QuickGraph\QuickGraphTest\Factories\BinaryHeapFactory.cs</title></head><body><div class="banner"></div><h2 id="top">d:\experimental3\BenchmarksAll\QuickGraph\QuickGraphTest\Factories\BinaryHeapFactory.cs</h2><div class="toggle"><p class="copyright"><a class="usercodeundertestcovered">user code under test</a>, 
  <span class="usercodeundertestnotcovered">user code under test (not covered)</span>, 
  <a class="userortestcodecovered">user code or test</a>, 
  <span class="userortestcodenotcovered">user code or test (not covered)</span>,
  <span class="tagged">tagged</span></p><table><tr><th>Methods</th></tr><tr><th /></tr></table><div class="toggle"><a class="button" href="#ID0EL">first</a><pre class="coverage">using System;
using Microsoft.Pex.Framework;
using QuickGraph;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace QuickGraphTest.Factories
{
    public static partial class BinaryHeapFactory
    {
        /*[PexFactoryMethod(typeof(QuickGraph.BinaryHeap&lt;int, int&gt;))]
        public static BinaryHeap&lt;int, int&gt; CreateBinaryHeapGeneral(int capacity, int[] priorities, int[] values)
        {
            PexAssume.IsTrue( priorities.Length == values.Length);
            var bh = new BinaryHeap&lt;int, int&gt;(capacity, Comparer&lt;int&gt;.Default.Compare);

            for (int i = 0; i &lt; priorities.Length; i++)
            {
                bh.Add(priorities[i], values[i]);
            }

            return bh;
        }*/

        /*[PexFactoryMethod(typeof(QuickGraph.BinaryHeap&lt;int, int&gt;))]
        public static BinaryHeap&lt;int, int&gt; CreateBinaryHeapKeyValPair([PexAssumeNotNull]KeyValuePair&lt;int,int&gt;[] pairs, int capacity)
        {
            PexAssume.IsTrue(capacity &lt; 11 &amp;&amp; capacity &gt; 0 &amp;&amp; pairs.Length &lt;= capacity);
            //PexAssume.TrueForAll(0, pairs.Length, _i =&gt; pairs[_i].Key &gt; -11 &amp;&amp; pairs[_i].Key &lt; 11 &amp;&amp; pairs[_i].Value &gt; -11 &amp;&amp; pairs[_i].Value &lt; 11);
            PexAssume.TrueForAll(0, pairs.Length, _i =&gt; pairs[_i].Key &gt; -101 &amp;&amp; pairs[_i].Key &lt; 101);
            
            var bh = new BinaryHeap&lt;int, int&gt;(capacity, Comparer&lt;int&gt;.Default.Compare);
            foreach (var pair in pairs)
            {
                bh.Add(pair.Key, pair.Value);
               
            }

            return bh;
        }*/

        [PexFactoryMethod(typeof(Tuple&lt;BinaryHeap&lt;int, int&gt;, BinaryHeap&lt;int, int&gt;&gt;))]
        public static Tuple&lt;BinaryHeap&lt;int, int&gt;, BinaryHeap&lt;int, int&gt;&gt; CreateBinaryHeapKeyValPair([PexAssumeNotNull]KeyValuePair&lt;int, int&gt;[] pairs, int capacity)
        <span id="ID0EL"><a class="button" href="#top">top</a>|<a class="button" href="#ID0E4B">next</a></span><span class="userortestcodenotcovered">{</span>
            <span class="userortestcodenotcovered">PexAssume.IsTrue(capacity &lt; 11 &amp;&amp; capacity &gt; 0);</span>
            <span class="userortestcodenotcovered">PexAssume.TrueForAll(0, pairs.Length, _i =&gt; </span><a class="button" href="#ID0EL">prev</a>|<span id="ID0E4B"><a class="button" href="#top">top</a></span><span class="userortestcodenotcovered">pairs[_i].Key &gt; -11 &amp;&amp; pairs[_i].Key &lt; 11</span><span class="userortestcodenotcovered">);</span>

            <span class="userortestcodenotcovered">var bh1 = new BinaryHeap&lt;int, int&gt;(capacity, Comparer&lt;int&gt;.Default.Compare);</span>
            <span class="userortestcodenotcovered">var bh2 = new BinaryHeap&lt;int, int&gt;(capacity, Comparer&lt;int&gt;.Default.Compare);</span>
            <span class="userortestcodenotcovered">foreach</span> (<span class="userortestcodenotcovered">var pair</span> <span class="userortestcodenotcovered">in</span> <span class="userortestcodenotcovered">pairs</span>)
            <span class="userortestcodenotcovered">{</span>
                <span class="userortestcodenotcovered">bh1.Add(pair.Key, pair.Value);</span>
                <span class="userortestcodenotcovered">bh2.Add(pair.Key, pair.Value);</span>
            <span class="userortestcodenotcovered">}</span>

            <span class="userortestcodenotcovered">var ret = new Tuple&lt;BinaryHeap&lt;int, int&gt;, BinaryHeap&lt;int, int&gt;&gt;(bh1, bh2);</span>
            <span class="userortestcodenotcovered">return ret;</span>
        <span class="userortestcodenotcovered">}</span>
    }
}
</pre></div></div><hr /><table width="100%"><tr><td valign="top"><span class="copyright">Copyright (c) Microsoft Corporation. All rights reserved.</span><br /><span class="button" onclick="copySourceToClipboard()">Copy full source to clipboard</span></td></tr></table><div id="debugdiv"> </div></body></html>
<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html>
<!-- saved from url=(0033)http://research.microsoft.com/pex -->
<head><link rel="StyleSheet" href="..\..\er.common.css" type="text/css" /><script src="..\..\er.common.js" type="text/javascript"> </script><link rel="SHORTCUT ICON" href="favicon.ico" /><link rel="icon" href="favicon.ico" type="image/x-icon" /><title>d:\experimental3\BenchmarksAll\QuickGraph\QuickGraph\BinaryHeap.cs</title></head><body><div class="banner"></div><h2 id="top">d:\experimental3\BenchmarksAll\QuickGraph\QuickGraph\BinaryHeap.cs</h2><div class="toggle"><p class="copyright"><a class="usercodeundertestcovered">user code under test</a>, 
  <span class="usercodeundertestnotcovered">user code under test (not covered)</span>, 
  <a class="userortestcodecovered">user code or test</a>, 
  <span class="userortestcodenotcovered">user code or test (not covered)</span>,
  <span class="tagged">tagged</span></p><table><tr><th>Methods</th></tr><tr><th /></tr></table><div class="toggle"><a class="button" href="#ID0EL">first</a><pre class="coverage">using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Collections;

using QuickGraph.Utility;
using QuickGraph.Interfaces;
using PexAPIWrapper;

namespace QuickGraph
{
    /// &lt;summary&gt;
    /// Binary heap
    /// &lt;/summary&gt;
    /// &lt;typeparam name="TValue"&gt;&lt;/typeparam&gt;
    /// &lt;remarks&gt;
    /// Indexing rules:
    /// 
    /// parent index: index ¡ 1)/2
    /// left child: 2 * index + 1
    /// right child: 2 * index + 2
    /// 
    /// Reference:
    /// http://dotnetslackers.com/Community/files/folders/data-structures-and-algorithms/entry28722.aspx
    /// &lt;/remarks&gt;
    // [DebuggerDisplay("Count = {Count}")]
    public class BinaryHeap&lt;TPriority, TValue&gt; :
        IEnumerable&lt;KeyValuePair&lt;TPriority, TValue&gt;&gt;
    {
        readonly Comparison&lt;TPriority&gt; priorityComparison;
        private KeyValuePair&lt;TPriority, TValue&gt;[] items;
        private int count;
        private int version;

        const int DefaultCapacity = 16;

        public BinaryHeap()
            : this(DefaultCapacity, Comparer&lt;TPriority&gt;.Default.Compare)
        { }

        public BinaryHeap(Comparison&lt;TPriority&gt; priorityComparison)
            : this(DefaultCapacity, priorityComparison)
        { }

        <span id="ID0EL"><a class="button" href="#top">top</a>|<a class="button" href="#ID0ERE">next</a></span><span class="usercodeundertestnotcovered">public BinaryHeap(int capacity, Comparison&lt;TPriority&gt; priorityComparison)</span>
        <span class="usercodeundertestnotcovered">{</span>
            <span class="usercodeundertestnotcovered">if (capacity &lt; 0)</span>
                <span class="usercodeundertestnotcovered">throw new ArgumentOutOfRangeException("capacity");</span>
            <span class="usercodeundertestnotcovered">if (priorityComparison == null)</span>
                <span class="usercodeundertestnotcovered">throw new ArgumentNullException("priorityComparison");</span>

            <span class="usercodeundertestnotcovered">this.items = new KeyValuePair&lt;TPriority, TValue&gt;[capacity];</span>
            <span class="usercodeundertestnotcovered">this.priorityComparison = priorityComparison;</span>
        <span class="usercodeundertestnotcovered">}</span>

        public Comparison&lt;TPriority&gt; PriorityComparison
        {
            get { return this.priorityComparison; }
        }

        public int Capacity
        {
            get <a class="button" href="#ID0EL">prev</a>|<span id="ID0ERE"><a class="button" href="#top">top</a>|<a class="button" href="#ID0EVG">next</a></span><a class="usercodeundertestcovered">{</a> <a class="usercodeundertestcovered">return this.items.Length;</a> <a class="usercodeundertestcovered">}</a>
        }

        public int Count
        {
            get <a class="button" href="#ID0EL">prev</a>|<span id="ID0EVG"><a class="button" href="#top">top</a>|<a class="button" href="#ID0EWAAC">next</a></span><a class="usercodeundertestcovered">{</a> <a class="usercodeundertestcovered">return this.count;</a> <a class="usercodeundertestcovered">}</a>
        }

        public void Add(TPriority priority, TValue value)
        <a class="button" href="#ID0EL">prev</a>|<span id="ID0EWAAC"><a class="button" href="#top">top</a>|<a class="button" href="#ID0EVDAC">next</a></span><span class="usercodeundertestnotcovered">{</span>
            //GraphContracts.Assert(count &lt;= this.items.Length);

            <span class="usercodeundertestnotcovered">this.version++;</span>
            <span class="usercodeundertestnotcovered">this.ResizeArray();</span>
            <span class="usercodeundertestnotcovered">this.items[this.count++] = new KeyValuePair&lt;TPriority, TValue&gt;(priority, value);</span>
            <span class="usercodeundertestnotcovered">this.MinHeapifyDown(this.count - 1);</span>
        <span class="usercodeundertestnotcovered">}</span>

        private void MinHeapifyDown(int start)
        <a class="button" href="#ID0EL">prev</a>|<span id="ID0EVDAC"><a class="button" href="#top">top</a>|<a class="button" href="#ID0EIIAC">next</a></span><span class="usercodeundertestnotcovered">{</span>
            <span class="usercodeundertestnotcovered">int i = start;</span>
            <span class="usercodeundertestnotcovered">int j = (i - 1) / 2;</span>
            <span class="usercodeundertestnotcovered">while (i &gt; 0 &amp;&amp;
                this.Less(i, j))</span>
            <span class="usercodeundertestnotcovered">{</span>
                <span class="usercodeundertestnotcovered">this.Swap(i, j);</span>
                <span class="usercodeundertestnotcovered">i = j;</span>
                <span class="usercodeundertestnotcovered">j = (i - 1) / 2;</span>
            <span class="usercodeundertestnotcovered">}</span>
        <span class="usercodeundertestnotcovered">}</span>

        private void ResizeArray()
        <a class="button" href="#ID0EL">prev</a>|<span id="ID0EIIAC"><a class="button" href="#top">top</a>|<a class="button" href="#ID0EBMAC">next</a></span><span class="usercodeundertestnotcovered">{</span>
            <span class="usercodeundertestnotcovered">if (this.count == this.items.Length)</span>
            <span class="usercodeundertestnotcovered">{</span>
                <span class="usercodeundertestnotcovered">var newItems = new KeyValuePair&lt;TPriority, TValue&gt;[this.count * 2 + 1];</span>
                <span class="usercodeundertestnotcovered">Array.Copy(this.items, newItems, this.count);</span>
                <span class="usercodeundertestnotcovered">this.items = newItems;</span>
            <span class="usercodeundertestnotcovered">}</span>
        <span class="usercodeundertestnotcovered">}</span>

        public KeyValuePair&lt;TPriority, TValue&gt; Minimum()
        <a class="button" href="#ID0EL">prev</a>|<span id="ID0EBMAC"><a class="button" href="#top">top</a>|<a class="button" href="#ID0EIAAE">next</a></span><a class="usercodeundertestcovered">{</a>
            //NotpAssume.IsTrue(this.count &gt;0);
            <a class="usercodeundertestcovered">if (this.count == 0)</a>
                <a class="usercodeundertestcovered">throw new InvalidOperationException();</a>
            <a class="usercodeundertestcovered">return this.items[0];</a>
        <a class="usercodeundertestcovered">}</a>

        public KeyValuePair&lt;TPriority, TValue&gt; RemoveMinimum()
        <a class="button" href="#ID0EL">prev</a>|<span id="ID0EIAAE"><a class="button" href="#top">top</a>|<a class="button" href="#ID0EYFAE">next</a></span><a class="usercodeundertestcovered">{</a>
            // shortcut for heap with 1 element.
            <a class="usercodeundertestcovered">if (this.count == 1)</a>
            <a class="usercodeundertestcovered">{</a>
                <a class="usercodeundertestcovered">this.version++;</a>
                <a class="usercodeundertestcovered">return this.items[--this.count];</a>
            }
            <a class="usercodeundertestcovered">return this.RemoveAt(0);</a>
        <a class="usercodeundertestcovered">}</a>

        public KeyValuePair&lt;TPriority, TValue&gt; RemoveAt(int index)
        <a class="button" href="#ID0EL">prev</a>|<span id="ID0EYFAE"><a class="button" href="#top">top</a>|<a class="button" href="#ID0EYPAE">next</a></span><a class="usercodeundertestcovered">{</a>
            //NotpAssume.IsTrue(this.count &gt;0);
            <a class="usercodeundertestcovered">if (this.count == 0)</a>
                <span class="usercodeundertestnotcovered">throw new InvalidOperationException("heap is empty");</span>
            //NotpAssume.IsTrue(index &gt;= 0 || index &lt;this.count || index + this.count &gt;= this.count);
            <a class="usercodeundertestcovered">if (index &lt; 0 | index &gt;= this.count | index + this.count &lt; this.count)</a>
                <span class="usercodeundertestnotcovered">throw new ArgumentOutOfRangeException("index");</span>

            <a class="usercodeundertestcovered">this.version++;</a>
            // shortcut for heap with 1 element.
            <a class="usercodeundertestcovered">if (this.count == 1)</a>
                <span class="usercodeundertestnotcovered">return this.items[--this.count];</span>

            <a class="usercodeundertestcovered">if (index &lt; this.count - 1)</a>
            <a class="usercodeundertestcovered">{</a>
                <a class="usercodeundertestcovered">this.Swap(index, this.count - 1);</a>
                <a class="usercodeundertestcovered">this.MinHeapifyUp(index);</a>
            <a class="usercodeundertestcovered">}</a>

            <a class="usercodeundertestcovered">return this.items[--this.count];</a>
        <a class="usercodeundertestcovered">}</a>

        private void MinHeapifyUp(int index)
        <a class="button" href="#ID0EL">prev</a>|<span id="ID0EYPAE"><a class="button" href="#top">top</a>|<a class="button" href="#ID0E2YAE">next</a></span><a class="usercodeundertestcovered">{</a>
            <a class="usercodeundertestcovered">var left = 2 * index + 1;</a>
            <a class="usercodeundertestcovered">var right = 2 * index + 2;</a>
            <a class="usercodeundertestcovered">while (
                    (left &lt; this.count - 1 &amp;&amp; !this.Less(index, left)) ||
                    (right &lt; this.count - 1 &amp;&amp; !this.Less(index, right))
                   )</a>
            <span class="usercodeundertestnotcovered">{</span>
                <span class="usercodeundertestnotcovered">if (right &gt;= this.count - 1 ||
                    this.Less(left, right))</span>
                <span class="usercodeundertestnotcovered">{</span>
                    <span class="usercodeundertestnotcovered">this.Swap(left, index);</span>
                    <span class="usercodeundertestnotcovered">index = left;</span>
                <span class="usercodeundertestnotcovered">}</span>
                else
                <span class="usercodeundertestnotcovered">{</span>
                    <span class="usercodeundertestnotcovered">this.Swap(right, index);</span>
                    <span class="usercodeundertestnotcovered">index = right;</span>
                <span class="usercodeundertestnotcovered">}</span>
                <span class="usercodeundertestnotcovered">left = 2 * index + 1;</span>
                <span class="usercodeundertestnotcovered">right = 2 * index + 2;</span>
            <span class="usercodeundertestnotcovered">}</span>
        <a class="usercodeundertestcovered">}</a>

        public int IndexOf(TValue value)
        {
            for (int i = 0; i &lt; this.count; i++)
            {
                if (object.Equals(value, this.items[i].Value))
                    return i;
            }
            return -1;
        }

        public void Update(TPriority priority, TValue value)
        {
            // find index
            var index = this.IndexOf(value);
            NotpAssume.IsTrue(index &gt;=0);
            if (index &lt; 0)
                throw new InvalidOperationException("value was not found in the heap");

            // remove and add
            this.RemoveAt(index);
            this.Add(priority, value);
        }

        private bool Less(int i, int j)
        <a class="button" href="#ID0EL">prev</a>|<span id="ID0E2YAE"><a class="button" href="#top">top</a>|<a class="button" href="#ID0E23AE">next</a></span><a class="usercodeundertestcovered">{</a>
            //GraphContracts.Assert(i &gt;= 0 &amp; i &lt; this.count &amp;
            //             j &gt;= 0 &amp; j &lt; this.count &amp;
            //             i != j, String.Format("i: {0}, j: {1}", i, j));

            <a class="usercodeundertestcovered">return this.priorityComparison(this.items[i].Key, this.items[j].Key) &lt;= 0;</a>
        <a class="usercodeundertestcovered">}</a>

        private void Swap(int i, int j)
        <a class="button" href="#ID0EL">prev</a>|<span id="ID0E23AE"><a class="button" href="#top">top</a>|<a class="button" href="#ID0ECCAG">next</a></span><a class="usercodeundertestcovered">{</a>
            //GraphContracts.Assert(i &gt;= 0 &amp; i &lt; this.count &amp;
            //             j &gt;= 0 &amp; j &lt; this.count &amp;
            //             i != j);

            <a class="usercodeundertestcovered">var kv = this.items[i];</a>
            <a class="usercodeundertestcovered">this.items[i] = this.items[j];</a>
            <a class="usercodeundertestcovered">this.items[j] = kv;</a>
        <a class="usercodeundertestcovered">}</a>

        [Conditional("DEBUG")]
        public void ObjectInvariant()
        {
            GraphContracts.Assert(this.items != null);
            GraphContracts.Assert(
                this.count &gt; -1 &amp;
                this.count &lt;= this.items.Length);
            for (int index = 0; index &lt; this.count; ++index)
            {
                var left = 2 * index + 1;
                GraphContracts.Assert(left &gt;= count || this.Less(index, left));
                var right = 2 * index + 2;
                GraphContracts.Assert(right &gt;= count || this.Less(index, right));
            }
        }

        #region IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; Members
        public IEnumerator&lt;KeyValuePair&lt;TPriority, TValue&gt;&gt; GetEnumerator()
        {
            return new Enumerator(this);
        }

        struct Enumerator :
            IEnumerator&lt;KeyValuePair&lt;TPriority, TValue&gt;&gt;
        {
            BinaryHeap&lt;TPriority, TValue&gt; owner;
            KeyValuePair&lt;TPriority, TValue&gt;[] items;
            readonly int count;
            readonly int version;
            int index;

            public Enumerator(BinaryHeap&lt;TPriority, TValue&gt; owner)
            {
                this.owner = owner;
                this.items = owner.items;
                this.count = owner.count;
                this.version = owner.version;
                this.index = -1;
            }

            public KeyValuePair&lt;TPriority, TValue&gt; Current
            {
                get
                {
                    if (this.version != this.owner.version)
                        throw new InvalidOperationException();
                    if (this.index &lt; 0 | this.index == this.count)
                        throw new InvalidOperationException();
                    //GraphContracts.Assert(this.index &lt;= this.count);
                    return this.items[this.index];
                }
            }

            void IDisposable.Dispose()
            {
                this.owner = null;
                this.items = null;
            }

            object IEnumerator.Current
            {
                get { return this.Current; }
            }

            public bool MoveNext()
            {
                if (this.version != this.owner.version)
                    throw new InvalidOperationException();
                return ++this.index &lt; this.count;
            }

            public void Reset()
            {
                if (this.version != this.owner.version)
                    throw new InvalidOperationException();
                this.index = -1;
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
        #endregion

        // Shiyu's code
        public Object Clone()
        {
            BinaryHeap&lt;TPriority, TValue&gt; bh = new BinaryHeap&lt;TPriority, TValue&gt;(this.Capacity, Comparer&lt;TPriority&gt;.Default.Compare);

            bh.count = this.count;
            bh.version = this.version;
            Array.Copy(this.items, bh.items, this.count);
            //foreach (var pair in this.items)
            //{
            //    bh.Add(pair.Key, pair.Value);
            //}
            return bh;
        }

        /*
        public virtual BinaryHeap&lt;int,int&gt; Clone()
        {
            BinaryHeap&lt;int, int&gt; bh = new BinaryHeap&lt;int, int&gt;(this.Capacity, Comparer&lt;int&gt;.Default.Compare);
            bh.count = this.count;
            bh.version = this.version;
            Array.Copy(this.items, bh.items, this.count);
            return bh;
        }*/

        public string ToStringForInts()
        <a class="button" href="#ID0EL">prev</a>|<span id="ID0ECCAG"><a class="button" href="#top">top</a></span><a class="usercodeundertestcovered">{</a>
            <a class="usercodeundertestcovered">string ret = "{";</a>
            for (<a class="usercodeundertestcovered">int i = 0;</a> <a class="usercodeundertestcovered">i &lt; this.count</a>; <a class="usercodeundertestcovered">i++</a>)
            <a class="usercodeundertestcovered">{</a>
                <a class="usercodeundertestcovered">ret += this.items[i].Key.ToString() + " " + this.items[i].Value.ToString() + " ";</a>
            <a class="usercodeundertestcovered">}</a>
            <a class="usercodeundertestcovered">return ret + "}";</a>
        <a class="usercodeundertestcovered">}</a>
    }
}
</pre></div></div><hr /><table width="100%"><tr><td valign="top"><span class="copyright">Copyright (c) Microsoft Corporation. All rights reserved.</span><br /><span class="button" onclick="copySourceToClipboard()">Copy full source to clipboard</span></td></tr></table><div id="debugdiv"> </div></body></html>
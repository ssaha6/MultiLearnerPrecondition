<documents created="2018-12-13 18:27:52Z"><document src="d:\experimental3\BenchmarksAll\DataStructures\DataStructures\ArrayList.cs" renderPrefix="s0"><chunk hits="-1" domain="unknown"><source><![CDATA[using System;
using System.Collections;
using System.Linq;
using System.Text;
using DataStructures.Utility;
namespace DataStructures
{
    /*
     * Source Code taken from https://github.com/dotnet/corefx/blob/master/src/System.Runtime.Extensions/src/System/Collections/ArrayList.cs
     * 
     */
    // Implements a variable-size List that uses an array of objects to store the
    // elements. A ArrayList has a capacity, which is the allocated length
    // of the internal array. As elements are added to a ArrayList, the capacity
    // of the ArrayList is automatically increased as required by reallocating the
    // internal array.
    // 
    //[DebuggerTypeProxy(typeof(System.Collections.ArrayList.ArrayListDebugView))]
    [System.Diagnostics.DebuggerDisplay("Count = {Count}")]
    [Serializable]
    //[System.Runtime.CompilerServices.TypeForwardedFrom("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
    public class ArrayList : System.Collections.IList, ICloneable
    {
        private Object[] _items; // Do not rename (binary serialization)
        private int _size; // Do not rename (binary serialization)
        private int _version; // Do not rename (binary serialization)
        [NonSerialized]
        private Object _syncRoot;

        private const int _defaultCapacity = 4;

        // Copy of Array.MaxArrayLength
        internal const int MaxArrayLength = 0X7FEFFFFF;

        // Note: this constructor is a bogus constructor that does nothing
        // and is for use only with SyncArrayList.
        internal ArrayList(bool trash)
        {
        }

        // Constructs a ArrayList. The list is initially empty and has a capacity
        // of zero. Upon adding the first element to the list the capacity is
        // increased to _defaultCapacity, and then increased in multiples of two as required.
        public ArrayList()
        {
            _items = EmptyArray<Object>.Value;
        }

        // Constructs a ArrayList with a given initial capacity. The list is
        // initially empty, but will have room for the given number of elements
        // before any reallocations are required.
        // 
        ]]></source>
</chunk>
<method name=".ctor" namespace="DataStructures" type="DataStructures.ArrayList" typeName="ArrayList" token="6000003" module="DataStructures.dll"><hits/>
<coverage domain="usercodeundertest" unit="block" covered="0" total="7" coveredRatio="0"/>
</method>
<chunk hits="0" offset="0000" domain="usercodeundertest"><source><![CDATA[public ArrayList(int capacity)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="0007" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0008" domain="usercodeundertest"><source><![CDATA[if (capacity < 0)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="0013" domain="usercodeundertest"><source><![CDATA[throw new ArgumentOutOfRangeException("nameof(capacity)", "SR.Format(SR.ArgumentOutOfRange_MustBeNonNegNum, nameof(capacity))");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            ]]></source>
</chunk>
<chunk hits="0" offset="0023" domain="usercodeundertest"><source><![CDATA[if (capacity == 0)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="002e" domain="usercodeundertest"><source><![CDATA[_items = EmptyArray<Object>.Value;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            else
                ]]></source>
</chunk>
<chunk hits="0" offset="003b" domain="usercodeundertest"><source><![CDATA[_items = new Object[capacity];]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="0047" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        // Constructs a ArrayList, copying the contents of the given collection. The
        // size and capacity of the new list will both be equal to the size of the
        // given collection.
        // 
        ]]></source>
</chunk>
<method name=".ctor" namespace="DataStructures" type="DataStructures.ArrayList" typeName="ArrayList" token="6000004" module="DataStructures.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="2" value="1"/>
<hit index="8" value="1"/>
<hit index="9" value="1"/>
<hit index="10" value="1"/>
<hit index="11" value="2"/>
<hit index="12" value="1"/>
<hit index="13" value="1"/>
<hit index="14" value="1"/>
<hit index="16" value="1"/>
<hit index="17" value="1"/>
<hit index="18" value="1"/>
<hit index="19" value="1"/>
<hit index="20" value="1"/>
<hit index="21" value="1"/>
<hit index="22" value="1"/>
<hit index="23" value="2"/>
<hit index="24" value="1"/>
<hit index="25" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="7" total="9" coveredRatio="0.77777777777777779"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[public ArrayList(System.Collections.ICollection c)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0007" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0008" domain="usercodeundertest"><source><![CDATA[if (c == null)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0013" domain="usercodeundertest"><source><![CDATA[throw new ArgumentNullException("nameof(c)", "SR.ArgumentNull_Collection");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            ]]></source>
</chunk>
<chunk hits="1" offset="0023" domain="usercodeundertest"><source><![CDATA[int count = c.Count;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="3" offset="002a" domain="usercodeundertest"><source><![CDATA[if (count == 0)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0035" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="1" offset="0036" domain="usercodeundertest"><source><![CDATA[_items = EmptyArray<Object>.Value;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="2" offset="0041" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            else
            ]]></source>
</chunk>
<chunk hits="1" offset="0044" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="1" offset="0045" domain="usercodeundertest"><source><![CDATA[_items = new Object[count];]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="2" offset="0051" domain="usercodeundertest"><source><![CDATA[AddRange(c);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="3" offset="0059" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="5" offset="005a" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        // Gets and sets the capacity of this list.  The capacity is the size of
        // the internal array used to hold items.  When set, the internal 
        // array of the list is reallocated to the given capacity.
        // 
        public virtual int Capacity
        {
            get
            {
                return _items.Length;
            }
            set
            ]]></source>
</chunk>
<method name="set_Capacity" namespace="DataStructures" type="DataStructures.ArrayList" typeName="ArrayList" token="6000006" module="DataStructures.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="7" value="1"/>
<hit index="8" value="1"/>
<hit index="9" value="1"/>
<hit index="10" value="1"/>
<hit index="12" value="1"/>
<hit index="13" value="1"/>
<hit index="14" value="1"/>
<hit index="15" value="1"/>
<hit index="16" value="1"/>
<hit index="17" value="1"/>
<hit index="18" value="1"/>
<hit index="19" value="1"/>
<hit index="20" value="1"/>
<hit index="21" value="1"/>
<hit index="27" value="1"/>
<hit index="30" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="8" total="11" coveredRatio="0.72727272727272729"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[if (value < _size)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0011" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    ]]></source>
</chunk>
<chunk hits="0" offset="0012" domain="usercodeundertest"><source><![CDATA[throw new ArgumentOutOfRangeException("nameof(value)", "SR.ArgumentOutOfRange_SmallCapacity");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                }

                // We don't want to update the version number when we change the capacity.
                // Some existing applications have dependency on this.
                ]]></source>
</chunk>
<chunk hits="1" offset="0022" domain="usercodeundertest"><source><![CDATA[if (value != _items.Length)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="1" offset="0031" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    ]]></source>
</chunk>
<chunk hits="1" offset="0032" domain="usercodeundertest"><source><![CDATA[if (value > 0)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    ]]></source>
</chunk>
<chunk hits="1" offset="003d" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                        ]]></source>
</chunk>
<chunk hits="1" offset="003e" domain="usercodeundertest"><source><![CDATA[Object[] newItems = new Object[value];]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                        ]]></source>
</chunk>
<chunk hits="1" offset="0045" domain="usercodeundertest"><source><![CDATA[if (_size > 0)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                        ]]></source>
</chunk>
<chunk hits="1" offset="0055" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                            ]]></source>
</chunk>
<chunk hits="1" offset="0056" domain="usercodeundertest"><source><![CDATA[Array.Copy(_items, 0, newItems, 0, _size);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                        ]]></source>
</chunk>
<chunk hits="1" offset="006b" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                        ]]></source>
</chunk>
<chunk hits="2" offset="006c" domain="usercodeundertest"><source><![CDATA[_items = newItems;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    ]]></source>
</chunk>
<chunk hits="2" offset="0073" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    else
                    ]]></source>
</chunk>
<chunk hits="0" offset="0076" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                        ]]></source>
</chunk>
<chunk hits="0" offset="0077" domain="usercodeundertest"><source><![CDATA[_items = new Object[_defaultCapacity];]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    ]]></source>
</chunk>
<chunk hits="0" offset="0083" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="2" offset="0084" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="2" offset="0085" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        }

        // Read-only property describing how many elements are in the List.
        public virtual int Count
        {
            get
            ]]></source>
</chunk>
<method name="get_Count" namespace="DataStructures" type="DataStructures.ArrayList" typeName="ArrayList" token="6000007" module="DataStructures.dll"><hits><hit index="0" value="10"/>
<hit index="1" value="10"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="1" total="1" coveredRatio="1"/>
</method>
<chunk hits="10" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="10" offset="0001" domain="usercodeundertest"><source><![CDATA[return _size;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="10" offset="000a" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        }

        public virtual bool IsFixedSize
        {
            get { return false; }
        }


        // Is this ArrayList read-only?
        public virtual bool IsReadOnly
        {
            get { return false; }
        }

        // Is this ArrayList synchronized (thread-safe)?
        public virtual bool IsSynchronized
        {
            get { return false; }
        }

        // Synchronization root for this object.
        public virtual Object SyncRoot
        {
            get
            {
                if (_syncRoot == null)
                {
                    System.Threading.Interlocked.CompareExchange<Object>(ref _syncRoot, new Object(), null);
                }
                return _syncRoot;
            }
        }

        // Sets or Gets the element at the given index.
        // 
        public virtual Object this[int index]
        {
            get
            ]]></source>
</chunk>
<method name="get_Item" namespace="DataStructures" type="DataStructures.ArrayList" typeName="ArrayList" token="600000c" module="DataStructures.dll"><hits><hit index="0" value="4"/>
<hit index="1" value="4"/>
<hit index="2" value="4"/>
<hit index="8" value="4"/>
<hit index="9" value="4"/>
<hit index="10" value="4"/>
<hit index="12" value="4"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="3" total="6" coveredRatio="0.5"/>
</method>
<chunk hits="4" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="4" offset="0001" domain="usercodeundertest"><source><![CDATA[if (index < 0 || index >= _size)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="0016" domain="usercodeundertest"><source><![CDATA[throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_Index");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="4" offset="0026" domain="usercodeundertest"><source><![CDATA[return _items[index];]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="8" offset="0031" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            set
            {
                if (index < 0 || index >= _size) throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_Index");
                _items[index] = value;
                _version++;
            }
        }

        // Creates a ArrayList wrapper for a particular IList.  This does not
        // copy the contents of the IList, but only wraps the IList.  So any
        // changes to the underlying list will affect the ArrayList.  This would
        // be useful if you want to Reverse a subrange of an IList, or want to
        // use a generic BinarySearch or Sort method without implementing one yourself.
        // However, since these methods are generic, the performance may not be
        // nearly as good for some operations as they would be on the IList itself.
        //
        public static ArrayList Adapter(IList list)
        {
            if (list == null)
                throw new ArgumentNullException("nameof(list)");
            return new IListWrapper(list);
        }

        // Adds the given object to the end of this list. The size of the list is
        // increased by one. If required, the capacity of the list is doubled
        // before adding the new element.
        //
        public virtual int Add(Object value)
        ]]></source>
</chunk>
<method name="Add" namespace="DataStructures" type="DataStructures.ArrayList" typeName="ArrayList" token="600000f" module="DataStructures.dll"><hits><hit index="0" value="2"/>
<hit index="1" value="2"/>
<hit index="2" value="2"/>
<hit index="3" value="2"/>
<hit index="4" value="1"/>
<hit index="5" value="1"/>
<hit index="6" value="1"/>
<hit index="7" value="1"/>
<hit index="8" value="2"/>
<hit index="9" value="2"/>
<hit index="10" value="2"/>
<hit index="11" value="2"/>
<hit index="12" value="2"/>
<hit index="13" value="2"/>
<hit index="14" value="2"/>
<hit index="15" value="2"/>
<hit index="16" value="2"/>
<hit index="17" value="2"/>
<hit index="18" value="2"/>
<hit index="19" value="2"/>
<hit index="20" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="4" total="4" coveredRatio="1"/>
</method>
<chunk hits="2" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="2" offset="0001" domain="usercodeundertest"><source><![CDATA[if (_size == _items.Length)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="1" offset="0018" domain="usercodeundertest"><source><![CDATA[EnsureCapacity(_size + 1);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="2" offset="0027" domain="usercodeundertest"><source><![CDATA[_items[_size] = value;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="8" offset="0035" domain="usercodeundertest"><source><![CDATA[_version++;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="4" offset="0043" domain="usercodeundertest"><source><![CDATA[return _size++;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="4" offset="0057" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        // Adds the elements of the given collection to the end of this list. If
        // required, the capacity of the list is increased to twice the previous
        // capacity or the new size, whichever is larger.
        //
        public virtual void AddRange(System.Collections.ICollection c)
        ]]></source>
</chunk>
<method name="AddRange" namespace="DataStructures" type="DataStructures.ArrayList" typeName="ArrayList" token="6000010" module="DataStructures.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="2" value="1"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="5" value="2"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[InsertRange(_size, c);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="3" offset="000f" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        // Searches a section of the list for a given element using a binary search
        // algorithm. Elements of the list are compared to the search value using
        // the given IComparer interface. If comparer is null, elements of
        // the list are compared to the search value using the IComparable
        // interface, which in that case must be implemented by all elements of the
        // list and the given search value. This method assumes that the given
        // section of the list is already sorted; if this is not the case, the
        // result will be incorrect.
        //
        // The method returns the index of the given value in the list. If the
        // list does not contain the given value, the method returns a negative
        // integer. The bitwise complement operator (~) can be applied to a
        // negative result to produce the index of the first element (if any) that
        // is larger than the given search value. This is also the index at which
        // the search value should be inserted into the list in order for the list
        // to remain sorted.
        // 
        // The method uses the Array.BinarySearch method to perform the
        // search.
        // 
        public virtual int BinarySearch(int index, int count, Object value, System.Collections.IComparer comparer)
        {
            if (index < 0)
                throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_NeedNonNegNum");
            if (count < 0)
                throw new ArgumentOutOfRangeException("nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
            if (_size - index < count)
                throw new ArgumentException("SR.Argument_InvalidOffLen");

            return Array.BinarySearch((Array)_items, index, count, value, comparer);
        }

        public virtual int BinarySearch(Object value)
        {
            return BinarySearch(0, Count, value, null);
        }

        public virtual int BinarySearch(Object value, IComparer comparer)
        {
            return BinarySearch(0, Count, value, comparer);
        }


        // Clears the contents of ArrayList.
        public virtual void Clear()
        {
            if (_size > 0)
            {
                Array.Clear(_items, 0, _size); // Don't need to doc this but we clear the elements so that the gc can reclaim the references.
                _size = 0;
            }
            _version++;
        }

        // Clones this ArrayList, doing a shallow copy.  (A copy is made of all
        // Object references in the ArrayList, but the Objects pointed to 
        // are not cloned).
        public virtual Object Clone()
        {
            ArrayList la = new ArrayList(_size);
            la._size = _size;
            la._version = _version;
            Array.Copy(_items, 0, la._items, 0, _size);
            return la;
        }


        // Contains returns true if the specified element is in the ArrayList.
        // It does a linear, O(n) search.  Equality is determined by calling
        // item.Equals().
        //
        public virtual bool Contains(Object item)
        ]]></source>
</chunk>
<method name="Contains" namespace="DataStructures" type="DataStructures.ArrayList" typeName="ArrayList" token="6000016" module="DataStructures.dll"><hits><hit index="0" value="4"/>
<hit index="8" value="5"/>
<hit index="9" value="5"/>
<hit index="10" value="5"/>
<hit index="11" value="5"/>
<hit index="12" value="5"/>
<hit index="13" value="5"/>
<hit index="14" value="5"/>
<hit index="15" value="5"/>
<hit index="16" value="5"/>
<hit index="17" value="5"/>
<hit index="18" value="10"/>
<hit index="19" value="4"/>
<hit index="20" value="8"/>
<hit index="21" value="4"/>
<hit index="22" value="4"/>
<hit index="26" value="4"/>
<hit index="27" value="5"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="8" total="14" coveredRatio="0.5714285714285714"/>
</method>
<chunk hits="4" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="4" offset="0001" domain="usercodeundertest"><source><![CDATA[if (item == null)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="000c" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                for (]]></source>
</chunk>
<chunk hits="0" offset="000d" domain="usercodeundertest"><source><![CDATA[int i = 0;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="002b" domain="usercodeundertest"><source><![CDATA[i < _size]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[; ]]></source>
</chunk>
<chunk hits="0" offset="0027" domain="usercodeundertest"><source><![CDATA[i++]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[)
                    ]]></source>
</chunk>
<chunk hits="0" offset="0011" domain="usercodeundertest"><source><![CDATA[if (_items[i] == null)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                        ]]></source>
</chunk>
<chunk hits="0" offset="0023" domain="usercodeundertest"><source><![CDATA[return true;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0038" domain="usercodeundertest"><source><![CDATA[return false;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }
            else
            ]]></source>
</chunk>
<chunk hits="4" offset="003c" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                for (]]></source>
</chunk>
<chunk hits="4" offset="003d" domain="usercodeundertest"><source><![CDATA[int i = 0;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="8" offset="006c" domain="usercodeundertest"><source><![CDATA[i < _size]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[; ]]></source>
</chunk>
<chunk hits="4" offset="0068" domain="usercodeundertest"><source><![CDATA[i++]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[)
                    ]]></source>
</chunk>
<chunk hits="5" offset="0041" domain="usercodeundertest"><source><![CDATA[if ((_items[i] != null) && (_items[i].Equals(item)))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                        ]]></source>
</chunk>
<chunk hits="4" offset="0064" domain="usercodeundertest"><source><![CDATA[return true;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="4" offset="0079" domain="usercodeundertest"><source><![CDATA[return false;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }
        ]]></source>
</chunk>
<chunk hits="8" offset="007d" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        // Copies this ArrayList into array, which must be of a 
        // compatible array type.  
        //
        public virtual void CopyTo(Array array)
        {
            CopyTo(array, 0);
        }

        // Copies this ArrayList into array, which must be of a 
        // compatible array type.  
        //
        public virtual void CopyTo(Array array, int arrayIndex)
        ]]></source>
</chunk>
<method name="CopyTo" namespace="DataStructures" type="DataStructures.ArrayList" typeName="ArrayList" token="6000018" module="DataStructures.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="2" value="1"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="5" value="2"/>
<hit index="11" value="1"/>
<hit index="12" value="1"/>
<hit index="13" value="1"/>
<hit index="14" value="1"/>
<hit index="16" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="5" total="8" coveredRatio="0.625"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[if ((array != null) && (array.Rank != 1))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0015" domain="usercodeundertest"><source><![CDATA[throw new ArgumentException("SR.Arg_RankMultiDimNotSupported", "nameof(array)");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            // Delegate rest of error checking to Array.Copy.
            ]]></source>
</chunk>
<chunk hits="1" offset="0025" domain="usercodeundertest"><source><![CDATA[Array.Copy(_items, 0, array, arrayIndex, _size);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="003a" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        // Copies a section of this list to the given array at the given index.
        // 
        // The method uses the Array.Copy method to copy the elements.
        // 
        public virtual void CopyTo(int index, Array array, int arrayIndex, int count)
        {
            if (_size - index < count)
                throw new ArgumentException("SR.Argument_InvalidOffLen");
            if ((array != null) && (array.Rank != 1))
                throw new ArgumentException("SR.Arg_RankMultiDimNotSupported", "nameof(array)");

            // Delegate rest of error checking to Array.Copy.
            Array.Copy(_items, index, array, arrayIndex, count);
        }

        // Ensures that the capacity of this list is at least the given minimum
        // value. If the current capacity of the list is less than min, the
        // capacity is increased to twice the current capacity or to min,
        // whichever is larger.
        private void EnsureCapacity(int min)
        ]]></source>
</chunk>
<method name="EnsureCapacity" namespace="DataStructures" type="DataStructures.ArrayList" typeName="ArrayList" token="600001a" module="DataStructures.dll"><hits><hit index="0" value="2"/>
<hit index="1" value="2"/>
<hit index="2" value="2"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="5" value="1"/>
<hit index="6" value="1"/>
<hit index="7" value="1"/>
<hit index="8" value="1"/>
<hit index="11" value="1"/>
<hit index="12" value="1"/>
<hit index="13" value="1"/>
<hit index="14" value="2"/>
<hit index="15" value="1"/>
<hit index="16" value="1"/>
<hit index="17" value="1"/>
<hit index="18" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="8" total="10" coveredRatio="0.8"/>
</method>
<chunk hits="2" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="2" offset="0001" domain="usercodeundertest"><source><![CDATA[if (_items.Length < min)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0013" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="1" offset="0014" domain="usercodeundertest"><source><![CDATA[int newCapacity = _items.Length == 0 ? _defaultCapacity : _items.Length * 2;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                // Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.
                // Note that this check works even when _items.Length overflowed thanks to the (uint) cast
                ]]></source>
</chunk>
<chunk hits="2" offset="002d" domain="usercodeundertest"><source><![CDATA[if ((uint)newCapacity > MaxArrayLength)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="003c" domain="usercodeundertest"><source><![CDATA[newCapacity = MaxArrayLength;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="1" offset="0042" domain="usercodeundertest"><source><![CDATA[if (newCapacity < min)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="004d" domain="usercodeundertest"><source><![CDATA[newCapacity = min;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="1" offset="004f" domain="usercodeundertest"><source><![CDATA[Capacity = newCapacity;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="3" offset="0057" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="4" offset="0058" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        // Returns a list wrapper that is fixed at the current size.  Operations
        // that add or remove items will fail, however, replacing items is allowed.
        //
        public static IList FixedSize(IList list)
        {
            if (list == null)
                throw new ArgumentNullException("nameof(list)");
            return new FixedSizeList(list);
        }

        // Returns a list wrapper that is fixed at the current size.  Operations
        // that add or remove items will fail, however, replacing items is allowed.
        //
        public static ArrayList FixedSize(ArrayList list)
        {
            if (list == null)
                throw new ArgumentNullException("nameof(list)");
            return new FixedSizeArrayList(list);
        }

        // Returns an enumerator for this list with the given
        // permission for removal of elements. If modifications made to the list 
        // while an enumeration is in progress, the MoveNext and 
        // GetObject methods of the enumerator will throw an exception.
        //
        public virtual IEnumerator GetEnumerator()
        {
            return new ArrayListEnumeratorSimple(this);
        }

        // Returns an enumerator for a section of this list with the given
        // permission for removal of elements. If modifications made to the list 
        // while an enumeration is in progress, the MoveNext and 
        // GetObject methods of the enumerator will throw an exception.
        //
        public virtual IEnumerator GetEnumerator(int index, int count)
        {
            if (index < 0)
                throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_NeedNonNegNum");
            if (count < 0)
                throw new ArgumentOutOfRangeException("nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
            if (_size - index < count)
                throw new ArgumentException("SR.Argument_InvalidOffLen");
            return new ArrayListEnumerator(this, index, count);
        }

        // Returns the index of the first occurrence of a given value in a range of
        // this list. The list is searched forwards from beginning to end.
        // The elements of the list are compared to the given value using the
        // Object.Equals method.
        // 
        // This method uses the Array.IndexOf method to perform the
        // search.
        // 
        public virtual int IndexOf(Object value)
        ]]></source>
</chunk>
<method name="IndexOf" namespace="DataStructures" type="DataStructures.ArrayList" typeName="ArrayList" token="600001f" module="DataStructures.dll"><hits><hit index="0" value="2"/>
<hit index="1" value="2"/>
<hit index="2" value="2"/>
<hit index="3" value="2"/>
<hit index="4" value="2"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<chunk hits="2" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="2" offset="0001" domain="usercodeundertest"><source><![CDATA[return Array.IndexOf((Array)_items, value, 0, _size);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="2" offset="0017" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        // Returns the index of the first occurrence of a given value in a range of
        // this list. The list is searched forwards, starting at index
        // startIndex and ending at count number of elements. The
        // elements of the list are compared to the given value using the
        // Object.Equals method.
        // 
        // This method uses the Array.IndexOf method to perform the
        // search.
        // 
        public virtual int IndexOf(Object value, int startIndex)
        {
            if (startIndex > _size)
                throw new ArgumentOutOfRangeException("nameof(startIndex)", "SR.ArgumentOutOfRange_Index");
            return Array.IndexOf((Array)_items, value, startIndex, _size - startIndex);
        }

        // Returns the index of the first occurrence of a given value in a range of
        // this list. The list is searched forwards, starting at index
        // startIndex and up to count number of elements. The
        // elements of the list are compared to the given value using the
        // Object.Equals method.
        // 
        // This method uses the Array.IndexOf method to perform the
        // search.
        // 
        public virtual int IndexOf(Object value, int startIndex, int count)
        {
            if (startIndex > _size)
                throw new ArgumentOutOfRangeException("nameof(startIndex)", "SR.ArgumentOutOfRange_Index");
            if (count < 0 || startIndex > _size - count) throw new ArgumentOutOfRangeException("nameof(count)", "SR.ArgumentOutOfRange_Count");
            return Array.IndexOf((Array)_items, value, startIndex, count);
        }

        // Inserts an element into this list at a given index. The size of the list
        // is increased by one. If required, the capacity of the list is doubled
        // before inserting the new element.
        // 
        public virtual void Insert(int index, Object value)
        {
            // Note that insertions at the end are legal.
            if (index < 0 || index > _size) throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_ArrayListInsert");

            if (_size == _items.Length) EnsureCapacity(_size + 1);
            if (index < _size)
            {
                Array.Copy(_items, index, _items, index + 1, _size - index);
            }
            _items[index] = value;
            _size++;
            _version++;
        }

        // Inserts the elements of the given collection at a given index. If
        // required, the capacity of the list is increased to twice the previous
        // capacity or the new size, whichever is larger.  Ranges may be added
        // to the end of the list by setting index to the ArrayList's size.
        //
        public virtual void InsertRange(int index, System.Collections.ICollection c)
        ]]></source>
</chunk>
<method name="InsertRange" namespace="DataStructures" type="DataStructures.ArrayList" typeName="ArrayList" token="6000023" module="DataStructures.dll"><hits><hit index="0" value="1"/>
<hit index="6" value="1"/>
<hit index="7" value="1"/>
<hit index="13" value="1"/>
<hit index="14" value="1"/>
<hit index="15" value="1"/>
<hit index="16" value="2"/>
<hit index="17" value="1"/>
<hit index="18" value="1"/>
<hit index="19" value="1"/>
<hit index="20" value="1"/>
<hit index="21" value="1"/>
<hit index="29" value="1"/>
<hit index="30" value="1"/>
<hit index="31" value="1"/>
<hit index="32" value="1"/>
<hit index="33" value="1"/>
<hit index="34" value="2"/>
<hit index="35" value="1"/>
<hit index="36" value="1"/>
<hit index="37" value="1"/>
<hit index="38" value="1"/>
<hit index="39" value="2"/>
<hit index="40" value="1"/>
<hit index="41" value="1"/>
<hit index="42" value="1"/>
<hit index="43" value="1"/>
<hit index="44" value="1"/>
<hit index="45" value="1"/>
<hit index="46" value="1"/>
<hit index="48" value="1"/>
<hit index="50" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="11" total="18" coveredRatio="0.61111111111111116"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[if (c == null)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="000c" domain="usercodeundertest"><source><![CDATA[throw new ArgumentNullException("nameof(c)", "SR.ArgumentNull_Collection");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="001c" domain="usercodeundertest"><source><![CDATA[if (index < 0 || index > _size)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="0034" domain="usercodeundertest"><source><![CDATA[throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_Index");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            ]]></source>
</chunk>
<chunk hits="1" offset="0044" domain="usercodeundertest"><source><![CDATA[int count = c.Count;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="3" offset="004b" domain="usercodeundertest"><source><![CDATA[if (count > 0)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0056" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="1" offset="0057" domain="usercodeundertest"><source><![CDATA[EnsureCapacity(_size + count);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                // shift existing items
                ]]></source>
</chunk>
<chunk hits="1" offset="0066" domain="usercodeundertest"><source><![CDATA[if (index < _size)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0076" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    ]]></source>
</chunk>
<chunk hits="0" offset="0077" domain="usercodeundertest"><source><![CDATA[Array.Copy(_items, index, _items, index + count, _size - index);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0095" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

                ]]></source>
</chunk>
<chunk hits="1" offset="0096" domain="usercodeundertest"><source><![CDATA[Object[] itemsToInsert = new Object[count];]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="1" offset="009d" domain="usercodeundertest"><source><![CDATA[c.CopyTo(itemsToInsert, 0);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="3" offset="00a6" domain="usercodeundertest"><source><![CDATA[itemsToInsert.CopyTo(_items, index);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="3" offset="00b4" domain="usercodeundertest"><source><![CDATA[_size += count;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="2" offset="00c2" domain="usercodeundertest"><source><![CDATA[_version++;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="2" offset="00d0" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="2" offset="00d1" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        // Returns the index of the last occurrence of a given value in a range of
        // this list. The list is searched backwards, starting at the end 
        // and ending at the first element in the list. The elements of the list 
        // are compared to the given value using the Object.Equals method.
        // 
        // This method uses the Array.LastIndexOf method to perform the
        // search.
        // 
        public virtual int LastIndexOf(Object value)
        ]]></source>
</chunk>
<method name="LastIndexOf" namespace="DataStructures" type="DataStructures.ArrayList" typeName="ArrayList" token="6000024" module="DataStructures.dll"><hits><hit index="0" value="2"/>
<hit index="1" value="2"/>
<hit index="2" value="2"/>
<hit index="3" value="2"/>
<hit index="4" value="2"/>
<hit index="5" value="2"/>
<hit index="6" value="4"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<chunk hits="2" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="2" offset="0001" domain="usercodeundertest"><source><![CDATA[return LastIndexOf(value, _size - 1, _size);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="6" offset="0019" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        // Returns the index of the last occurrence of a given value in a range of
        // this list. The list is searched backwards, starting at index
        // startIndex and ending at the first element in the list. The 
        // elements of the list are compared to the given value using the 
        // Object.Equals method.
        // 
        // This method uses the Array.LastIndexOf method to perform the
        // search.
        // 
        public virtual int LastIndexOf(Object value, int startIndex)
        {
            if (startIndex >= _size)
                throw new ArgumentOutOfRangeException("nameof(startIndex)", "SR.ArgumentOutOfRange_Index");
            return LastIndexOf(value, startIndex, startIndex + 1);
        }

        // Returns the index of the last occurrence of a given value in a range of
        // this list. The list is searched backwards, starting at index
        // startIndex and up to count elements. The elements of
        // the list are compared to the given value using the Object.Equals
        // method.
        // 
        // This method uses the Array.LastIndexOf method to perform the
        // search.
        // 
        public virtual int LastIndexOf(Object value, int startIndex, int count)
        ]]></source>
</chunk>
<method name="LastIndexOf" namespace="DataStructures" type="DataStructures.ArrayList" typeName="ArrayList" token="6000026" module="DataStructures.dll"><hits><hit index="0" value="2"/>
<hit index="1" value="2"/>
<hit index="2" value="2"/>
<hit index="3" value="2"/>
<hit index="4" value="4"/>
<hit index="5" value="2"/>
<hit index="6" value="2"/>
<hit index="13" value="2"/>
<hit index="14" value="2"/>
<hit index="15" value="2"/>
<hit index="16" value="2"/>
<hit index="24" value="2"/>
<hit index="25" value="2"/>
<hit index="26" value="2"/>
<hit index="27" value="2"/>
<hit index="29" value="2"/>
<hit index="31" value="2"/>
<hit index="33" value="2"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="11" total="21" coveredRatio="0.52380952380952384"/>
</method>
<chunk hits="2" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="2" offset="0001" domain="usercodeundertest"><source><![CDATA[if (Count != 0 && (startIndex < 0 || count < 0))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0020" domain="usercodeundertest"><source><![CDATA[throw new ArgumentOutOfRangeException(startIndex < 0 ? "nameof(startIndex)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            ]]></source>
</chunk>
<chunk hits="2" offset="003c" domain="usercodeundertest"><source><![CDATA[if (_size == 0)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[  // Special case for an empty list
                ]]></source>
</chunk>
<chunk hits="2" offset="004c" domain="usercodeundertest"><source><![CDATA[return -1;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            ]]></source>
</chunk>
<chunk hits="2" offset="0050" domain="usercodeundertest"><source><![CDATA[if (startIndex >= _size || count > startIndex + 1)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="006a" domain="usercodeundertest"><source><![CDATA[throw new ArgumentOutOfRangeException(startIndex >= _size ? "nameof(startIndex)" : "nameof(count)", "SR.ArgumentOutOfRange_BiggerThanCollection");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            ]]></source>
</chunk>
<chunk hits="2" offset="008b" domain="usercodeundertest"><source><![CDATA[return Array.LastIndexOf((Array)_items, value, startIndex, count);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="4" offset="009c" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        // Returns a read-only IList wrapper for the given IList.
        //
        public static IList ReadOnly(IList list)
        {
            if (list == null)
                throw new ArgumentNullException("nameof(list)");
            return new ReadOnlyList(list);
        }

        // Returns a read-only ArrayList wrapper for the given ArrayList.
        //
        public static ArrayList ReadOnly(ArrayList list)
        {
            if (list == null)
                throw new ArgumentNullException("nameof(list)");
            return new ReadOnlyArrayList(list);
        }

        // Removes the element at the given index. The size of the list is
        // decreased by one.
        // 
        public virtual void Remove(Object obj)
        {
            int index = IndexOf(obj);
            if (index >= 0)
                RemoveAt(index);
        }

        // Removes the element at the given index. The size of the list is
        // decreased by one.
        // 
        public virtual void RemoveAt(int index)
        {
            if (index < 0 || index >= _size) throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_Index");

            _size--;
            if (index < _size)
            {
                Array.Copy(_items, index + 1, _items, index, _size - index);
            }
            _items[_size] = null;
            _version++;
        }

        // Removes a range of elements from this list.
        // 
        public virtual void RemoveRange(int index, int count)
        {
            if (index < 0)
                throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_NeedNonNegNum");
            if (count < 0)
                throw new ArgumentOutOfRangeException("nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
            if (_size - index < count)
                throw new ArgumentException("SR.Argument_InvalidOffLen");

            if (count > 0)
            {
                int i = _size;
                _size -= count;
                if (index < _size)
                {
                    Array.Copy(_items, index + count, _items, index, _size - index);
                }
                while (i > _size) _items[--i] = null;
                _version++;
            }
        }

        // Returns an IList that contains count copies of value.
        //
        public static ArrayList Repeat(Object value, int count)
        {
            if (count < 0)
                throw new ArgumentOutOfRangeException("nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");

            ArrayList list = new ArrayList((count > _defaultCapacity) ? count : _defaultCapacity);
            for (int i = 0; i < count; i++)
                list.Add(value);
            return list;
        }

        // Reverses the elements in this list.
        public virtual void Reverse()
        {
            Reverse(0, Count);
        }

        // Reverses the elements in a range of this list. Following a call to this
        // method, an element in the range given by index and count
        // which was previously located at index i will now be located at
        // index index + (index + count - i - 1).
        // 
        // This method uses the Array.Reverse method to reverse the
        // elements.
        // 
        public virtual void Reverse(int index, int count)
        {
            if (index < 0)
                throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_NeedNonNegNum");
            if (count < 0)
                throw new ArgumentOutOfRangeException("nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
            if (_size - index < count)
                throw new ArgumentException("SR.Argument_InvalidOffLen");

            Array.Reverse(_items, index, count);
            _version++;
        }

        // Sets the elements starting at the given index to the elements of the
        // given collection.
        //
        public virtual void SetRange(int index, ICollection c)
        {
            if (c == null) throw new ArgumentNullException("nameof(c)", "SR.ArgumentNull_Collection");

            int count = c.Count;
            if (index < 0 || index > _size - count) throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_Index");

            if (count > 0)
            {
                c.CopyTo(_items, index);
                _version++;
            }
        }

        public virtual ArrayList GetRange(int index, int count)
        {
            if (index < 0 || count < 0)
                throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
            if (_size - index < count)
                throw new ArgumentException("SR.Argument_InvalidOffLen");
            return new Range(this, index, count);
        }

        // Sorts the elements in this list.  Uses the default comparer and 
        // Array.Sort.
        public virtual void Sort()
        {
            Sort(0, Count, Comparer.Default);
        }

        // Sorts the elements in this list.  Uses Array.Sort with the
        // provided comparer.
        public virtual void Sort(IComparer comparer)
        {
            Sort(0, Count, comparer);
        }

        // Sorts the elements in a section of this list. The sort compares the
        // elements to each other using the given IComparer interface. If
        // comparer is null, the elements are compared to each other using
        // the IComparable interface, which in that case must be implemented by all
        // elements of the list.
        // 
        // This method uses the Array.Sort method to sort the elements.
        // 
        public virtual void Sort(int index, int count, IComparer comparer)
        {
            if (index < 0)
                throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_NeedNonNegNum");
            if (count < 0)
                throw new ArgumentOutOfRangeException("nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
            if (_size - index < count)
                throw new ArgumentException("SR.Argument_InvalidOffLen");

            Array.Sort(_items, index, count, comparer);
            _version++;
        }

        // Returns a thread-safe wrapper around an IList.
        //
        public static IList Synchronized(IList list)
        {
            if (list == null)
                throw new ArgumentNullException("nameof(list)");
            return new SyncIList(list);
        }

        // Returns a thread-safe wrapper around a ArrayList.
        //
        public static ArrayList Synchronized(ArrayList list)
        {
            if (list == null)
                throw new ArgumentNullException("nameof(list)");
            return new SyncArrayList(list);
        }

        // ToArray returns a new Object array containing the contents of the ArrayList.
        // This requires copying the ArrayList, which is an O(n) operation.
        public virtual Object[] ToArray()
        {
            if (_size == 0)
                return EmptyArray<Object>.Value;

            Object[] array = new Object[_size];
            Array.Copy(_items, 0, array, 0, _size);
            return array;
        }

        // ToArray returns a new array of a particular type containing the contents 
        // of the ArrayList.  This requires copying the ArrayList and potentially
        // downcasting all elements.  This copy may fail and is an O(n) operation.
        // Internally, this implementation calls Array.Copy.
        //
        public virtual Array ToArray(Type type)
        {
            if (type == null)
                throw new ArgumentNullException("nameof(type)");

            Array array = Array.CreateInstance(type, _size);
            Array.Copy(_items, 0, array, 0, _size);
            return array;
        }

        // Sets the capacity of this list to the size of the list. This method can
        // be used to minimize a list's memory overhead once it is known that no
        // new elements will be added to the list. To completely clear a list and
        // release all memory referenced by the list, execute the following
        // statements:
        // 
        // list.Clear();
        // list.TrimToSize();
        // 
        public virtual void TrimToSize()
        {
            Capacity = _size;
        }


        // This class wraps an IList, exposing it as a ArrayList
        // Note this requires reimplementing half of ArrayList...
        private class IListWrapper : ArrayList
        {
            private IList _list;

            internal IListWrapper(IList list)
            {
                _list = list;
                _version = 0; // list doesn't not contain a version number
            }

            public override int Capacity
            {
                get { return _list.Count; }
                set
                {
                    if (value < Count) throw new ArgumentOutOfRangeException("nameof(value)", "SR.ArgumentOutOfRange_SmallCapacity");
                }
            }

            public override int Count
            {
                get { return _list.Count; }
            }

            public override bool IsReadOnly
            {
                get { return _list.IsReadOnly; }
            }

            public override bool IsFixedSize
            {
                get { return _list.IsFixedSize; }
            }


            public override bool IsSynchronized
            {
                get { return _list.IsSynchronized; }
            }

            public override Object this[int index]
            {
                get
                {
                    return _list[index];
                }
                set
                {
                    _list[index] = value;
                    _version++;
                }
            }

            public override Object SyncRoot
            {
                get { return _list.SyncRoot; }
            }

            public override int Add(Object obj)
            {
                int i = _list.Add(obj);
                _version++;
                return i;
            }

            public override void AddRange(ICollection c)
            {
                InsertRange(Count, c);
            }

            // Other overloads with automatically work
            public override int BinarySearch(int index, int count, Object value, IComparer comparer)
            {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (Count - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                if (comparer == null)
                    comparer = Comparer.Default;

                int lo = index;
                int hi = index + count - 1;
                int mid;
                while (lo <= hi)
                {
                    mid = (lo + hi) / 2;
                    int r = comparer.Compare(value, _list[mid]);
                    if (r == 0)
                        return mid;
                    if (r < 0)
                        hi = mid - 1;
                    else
                        lo = mid + 1;
                }
                // return bitwise complement of the first element greater than value.
                // Since hi is less than lo now, ~lo is the correct item.
                return ~lo;
            }

            public override void Clear()
            {
                // If _list is an array, it will support Clear method.
                // We shouldn't allow clear operation on a FixedSized ArrayList
                if (_list.IsFixedSize)
                {
                    throw new NotSupportedException("SR.NotSupported_FixedSizeCollection");
                }

                _list.Clear();
                _version++;
            }

            public override Object Clone()
            {
                // This does not do a shallow copy of _list into a ArrayList!
                // This clones the IListWrapper, creating another wrapper class!
                return new IListWrapper(_list);
            }

            public override bool Contains(Object obj)
            {
                return _list.Contains(obj);
            }

            public override void CopyTo(Array array, int index)
            {
                _list.CopyTo(array, index);
            }

            public override void CopyTo(int index, Array array, int arrayIndex, int count)
            {
                if (array == null)
                    throw new ArgumentNullException("nameof(array)");
                if (index < 0 || arrayIndex < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(arrayIndex)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (count < 0)
                    throw new ArgumentOutOfRangeException("nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (array.Length - arrayIndex < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");
                if (array.Rank != 1)
                    throw new ArgumentException("SR.Arg_RankMultiDimNotSupported", "nameof(array)");

                if (_list.Count - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                for (int i = index; i < index + count; i++)
                    array.SetValue(_list[i], arrayIndex++);
            }

            public override IEnumerator GetEnumerator()
            {
                return _list.GetEnumerator();
            }

            public override IEnumerator GetEnumerator(int index, int count)
            {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");

                if (_list.Count - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                return new IListWrapperEnumWrapper(this, index, count);
            }

            public override int IndexOf(Object value)
            {
                return _list.IndexOf(value);
            }

            ////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int IndexOf(Object value, int startIndex)
            {
                return IndexOf(value, startIndex, _list.Count - startIndex);
            }

            public override int IndexOf(Object value, int startIndex, int count)
            {
                if (startIndex < 0 || startIndex > Count) throw new ArgumentOutOfRangeException("nameof(startIndex)", "SR.ArgumentOutOfRange_Index");
                if (count < 0 || startIndex > Count - count) throw new ArgumentOutOfRangeException("nameof(count)", "SR.ArgumentOutOfRange_Count");

                int endIndex = startIndex + count;
                if (value == null)
                {
                    for (int i = startIndex; i < endIndex; i++)
                        if (_list[i] == null)
                            return i;
                    return -1;
                }
                else
                {
                    for (int i = startIndex; i < endIndex; i++)
                        if (_list[i] != null && _list[i].Equals(value))
                            return i;
                    return -1;
                }
            }

            public override void Insert(int index, Object obj)
            {
                _list.Insert(index, obj);
                _version++;
            }

            public override void InsertRange(int index, ICollection c)
            {
                if (c == null)
                    throw new ArgumentNullException("nameof(c)", "SR.ArgumentNull_Collection");
                if (index < 0 || index > Count) throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_Index");

                if (c.Count > 0)
                {
                    ArrayList al = _list as ArrayList;
                    if (al != null)
                    {
                        // We need to special case ArrayList. 
                        // When c is a range of _list, we need to handle this in a special way.
                        // See ArrayList.InsertRange for details.
                        al.InsertRange(index, c);
                    }
                    else
                    {
                        IEnumerator en = c.GetEnumerator();
                        while (en.MoveNext())
                        {
                            _list.Insert(index++, en.Current);
                        }
                    }
                    _version++;
                }
            }

            public override int LastIndexOf(Object value)
            {
                return LastIndexOf(value, _list.Count - 1, _list.Count);
            }

            ////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int LastIndexOf(Object value, int startIndex)
            {
                return LastIndexOf(value, startIndex, startIndex + 1);
            }

            ////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int LastIndexOf(Object value, int startIndex, int count)
            {
                if (_list.Count == 0)
                    return -1;

                if (startIndex < 0 || startIndex >= _list.Count) throw new ArgumentOutOfRangeException("nameof(startIndex)", "SR.ArgumentOutOfRange_Index");
                if (count < 0 || count > startIndex + 1) throw new ArgumentOutOfRangeException("nameof(count)", "SR.ArgumentOutOfRange_Count");

                int endIndex = startIndex - count + 1;
                if (value == null)
                {
                    for (int i = startIndex; i >= endIndex; i--)
                        if (_list[i] == null)
                            return i;
                    return -1;
                }
                else
                {
                    for (int i = startIndex; i >= endIndex; i--)
                        if (_list[i] != null && _list[i].Equals(value))
                            return i;
                    return -1;
                }
            }

            public override void Remove(Object value)
            {
                int index = IndexOf(value);
                if (index >= 0)
                    RemoveAt(index);
            }

            public override void RemoveAt(int index)
            {
                _list.RemoveAt(index);
                _version++;
            }

            public override void RemoveRange(int index, int count)
            {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");

                if (_list.Count - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                if (count > 0)    // be consistent with ArrayList
                    _version++;

                while (count > 0)
                {
                    _list.RemoveAt(index);
                    count--;
                }
            }

            public override void Reverse(int index, int count)
            {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");

                if (_list.Count - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                int i = index;
                int j = index + count - 1;
                while (i < j)
                {
                    Object tmp = _list[i];
                    _list[i++] = _list[j];
                    _list[j--] = tmp;
                }
                _version++;
            }

            public override void SetRange(int index, ICollection c)
            {
                if (c == null)
                {
                    throw new ArgumentNullException("nameof(c)", "SR.ArgumentNull_Collection");
                }

                if (index < 0 || index > _list.Count - c.Count)
                {
                    throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_Index");
                }

                if (c.Count > 0)
                {
                    IEnumerator en = c.GetEnumerator();
                    while (en.MoveNext())
                    {
                        _list[index++] = en.Current;
                    }
                    _version++;
                }
            }

            public override ArrayList GetRange(int index, int count)
            {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (_list.Count - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");
                return new Range(this, index, count);
            }

            public override void Sort(int index, int count, IComparer comparer)
            {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (_list.Count - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                Object[] array = new Object[count];
                CopyTo(index, array, 0, count);
                Array.Sort(array, 0, count, comparer);
                for (int i = 0; i < count; i++)
                    _list[i + index] = array[i];

                _version++;
            }


            public override Object[] ToArray()
            {
                if (Count == 0)
                    return EmptyArray<Object>.Value;

                Object[] array = new Object[Count];
                _list.CopyTo(array, 0);
                return array;
            }

            public override Array ToArray(Type type)
            {
                if (type == null)
                    throw new ArgumentNullException("nameof(type)");

                Array array = Array.CreateInstance(type, _list.Count);
                _list.CopyTo(array, 0);
                return array;
            }

            public override void TrimToSize()
            {
                // Can't really do much here...
            }

            // This is the enumerator for an IList that's been wrapped in another
            // class that implements all of ArrayList's methods.
            private sealed class IListWrapperEnumWrapper : IEnumerator, ICloneable
            {
                private IEnumerator _en;
                private int _remaining;
                private int _initialStartIndex; // for reset
                private int _initialCount;      // for reset
                private bool _firstCall;        // firstCall to MoveNext

                internal IListWrapperEnumWrapper(IListWrapper listWrapper, int startIndex, int count)
                {
                    _en = listWrapper.GetEnumerator();
                    _initialStartIndex = startIndex;
                    _initialCount = count;
                    while (startIndex-- > 0 && _en.MoveNext()) ;
                    _remaining = count;
                    _firstCall = true;
                }

                private IListWrapperEnumWrapper() { }

                public object Clone()
                {
                    var clone = new IListWrapperEnumWrapper();
                    clone._en = (IEnumerator)((ICloneable)_en).Clone();
                    clone._initialStartIndex = _initialStartIndex;
                    clone._initialCount = _initialCount;
                    clone._remaining = _remaining;
                    clone._firstCall = _firstCall;
                    return clone;
                }

                public bool MoveNext()
                {
                    if (_firstCall)
                    {
                        _firstCall = false;
                        return _remaining-- > 0 && _en.MoveNext();
                    }
                    if (_remaining < 0)
                        return false;
                    bool r = _en.MoveNext();
                    return r && _remaining-- > 0;
                }

                public Object Current
                {
                    get
                    {
                        if (_firstCall)
                            throw new InvalidOperationException("SR.InvalidOperation_EnumNotStarted");
                        if (_remaining < 0)
                            throw new InvalidOperationException("SR.InvalidOperation_EnumEnded");
                        return _en.Current;
                    }
                }

                public void Reset()
                {
                    _en.Reset();
                    int startIndex = _initialStartIndex;
                    while (startIndex-- > 0 && _en.MoveNext()) ;
                    _remaining = _initialCount;
                    _firstCall = true;
                }
            }
        }

        private class SyncArrayList : ArrayList
        {
            private ArrayList _list;
            private Object _root;

            internal SyncArrayList(ArrayList list)
                : base(false)
            {
                _list = list;
                _root = list.SyncRoot;
            }

            public override int Capacity
            {
                get
                {
                    lock (_root)
                    {
                        return _list.Capacity;
                    }
                }
                ////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
                set
                {
                    lock (_root)
                    {
                        _list.Capacity = value;
                    }
                }
            }

            public override int Count
            {
                get { lock (_root) { return _list.Count; } }
            }

            public override bool IsReadOnly
            {
                get { return _list.IsReadOnly; }
            }

            public override bool IsFixedSize
            {
                get { return _list.IsFixedSize; }
            }


            public override bool IsSynchronized
            {
                get { return true; }
            }

            public override Object this[int index]
            {
                get
                {
                    lock (_root)
                    {
                        return _list[index];
                    }
                }
                set
                {
                    lock (_root)
                    {
                        _list[index] = value;
                    }
                }
            }

            public override Object SyncRoot
            {
                get { return _root; }
            }

            public override int Add(Object value)
            {
                lock (_root)
                {
                    return _list.Add(value);
                }
            }

            public override void AddRange(ICollection c)
            {
                lock (_root)
                {
                    _list.AddRange(c);
                }
            }

            public override int BinarySearch(Object value)
            {
                lock (_root)
                {
                    return _list.BinarySearch(value);
                }
            }

            public override int BinarySearch(Object value, IComparer comparer)
            {
                lock (_root)
                {
                    return _list.BinarySearch(value, comparer);
                }
            }

            ////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int BinarySearch(int index, int count, Object value, IComparer comparer)
            {
                lock (_root)
                {
                    return _list.BinarySearch(index, count, value, comparer);
                }
            }

            public override void Clear()
            {
                lock (_root)
                {
                    _list.Clear();
                }
            }

            public override Object Clone()
            {
                lock (_root)
                {
                    return new SyncArrayList((ArrayList)_list.Clone());
                }
            }

            public override bool Contains(Object item)
            {
                lock (_root)
                {
                    return _list.Contains(item);
                }
            }

            public override void CopyTo(Array array)
            {
                lock (_root)
                {
                    _list.CopyTo(array);
                }
            }

            public override void CopyTo(Array array, int index)
            {
                lock (_root)
                {
                    _list.CopyTo(array, index);
                }
            }

            ////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void CopyTo(int index, Array array, int arrayIndex, int count)
            {
                lock (_root)
                {
                    _list.CopyTo(index, array, arrayIndex, count);
                }
            }

            public override IEnumerator GetEnumerator()
            {
                lock (_root)
                {
                    return _list.GetEnumerator();
                }
            }

            ////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override IEnumerator GetEnumerator(int index, int count)
            {
                lock (_root)
                {
                    return _list.GetEnumerator(index, count);
                }
            }

            public override int IndexOf(Object value)
            {
                lock (_root)
                {
                    return _list.IndexOf(value);
                }
            }

            ////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int IndexOf(Object value, int startIndex)
            {
                lock (_root)
                {
                    return _list.IndexOf(value, startIndex);
                }
            }

            ////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int IndexOf(Object value, int startIndex, int count)
            {
                lock (_root)
                {
                    return _list.IndexOf(value, startIndex, count);
                }
            }

            public override void Insert(int index, Object value)
            {
                lock (_root)
                {
                    _list.Insert(index, value);
                }
            }

            ////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void InsertRange(int index, ICollection c)
            {
                lock (_root)
                {
                    _list.InsertRange(index, c);
                }
            }

            public override int LastIndexOf(Object value)
            {
                lock (_root)
                {
                    return _list.LastIndexOf(value);
                }
            }

            //////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int LastIndexOf(Object value, int startIndex)
            {
                lock (_root)
                {
                    return _list.LastIndexOf(value, startIndex);
                }
            }

            //////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int LastIndexOf(Object value, int startIndex, int count)
            {
                lock (_root)
                {
                    return _list.LastIndexOf(value, startIndex, count);
                }
            }

            public override void Remove(Object value)
            {
                lock (_root)
                {
                    _list.Remove(value);
                }
            }

            public override void RemoveAt(int index)
            {
                lock (_root)
                {
                    _list.RemoveAt(index);
                }
            }

            ////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void RemoveRange(int index, int count)
            {
                lock (_root)
                {
                    _list.RemoveRange(index, count);
                }
            }

            ////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void Reverse(int index, int count)
            {
                lock (_root)
                {
                    _list.Reverse(index, count);
                }
            }

            ////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void SetRange(int index, ICollection c)
            {
                lock (_root)
                {
                    _list.SetRange(index, c);
                }
            }

            ////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override ArrayList GetRange(int index, int count)
            {
                lock (_root)
                {
                    return _list.GetRange(index, count);
                }
            }

            public override void Sort()
            {
                lock (_root)
                {
                    _list.Sort();
                }
            }

            public override void Sort(IComparer comparer)
            {
                lock (_root)
                {
                    _list.Sort(comparer);
                }
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void Sort(int index, int count, IComparer comparer)
            {
                lock (_root)
                {
                    _list.Sort(index, count, comparer);
                }
            }

            public override Object[] ToArray()
            {
                lock (_root)
                {
                    return _list.ToArray();
                }
            }

            ////[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override Array ToArray(Type type)
            {
                lock (_root)
                {
                    return _list.ToArray(type);
                }
            }

            public override void TrimToSize()
            {
                lock (_root)
                {
                    _list.TrimToSize();
                }
            }
        }


        private class SyncIList : IList
        {
            private IList _list;
            private Object _root;

            internal SyncIList(IList list)
            {
                _list = list;
                _root = list.SyncRoot;
            }

            public virtual int Count
            {
                get { lock (_root) { return _list.Count; } }
            }

            public virtual bool IsReadOnly
            {
                get { return _list.IsReadOnly; }
            }

            public virtual bool IsFixedSize
            {
                get { return _list.IsFixedSize; }
            }


            public virtual bool IsSynchronized
            {
                get { return true; }
            }

            public virtual Object this[int index]
            {
                get
                {
                    lock (_root)
                    {
                        return _list[index];
                    }
                }
                set
                {
                    lock (_root)
                    {
                        _list[index] = value;
                    }
                }
            }

            public virtual Object SyncRoot
            {
                get { return _root; }
            }

            public virtual int Add(Object value)
            {
                lock (_root)
                {
                    return _list.Add(value);
                }
            }


            public virtual void Clear()
            {
                lock (_root)
                {
                    _list.Clear();
                }
            }

            public virtual bool Contains(Object item)
            {
                lock (_root)
                {
                    return _list.Contains(item);
                }
            }

            public virtual void CopyTo(Array array, int index)
            {
                lock (_root)
                {
                    _list.CopyTo(array, index);
                }
            }

            public virtual IEnumerator GetEnumerator()
            {
                lock (_root)
                {
                    return _list.GetEnumerator();
                }
            }

            public virtual int IndexOf(Object value)
            {
                lock (_root)
                {
                    return _list.IndexOf(value);
                }
            }

            public virtual void Insert(int index, Object value)
            {
                lock (_root)
                {
                    _list.Insert(index, value);
                }
            }

            public virtual void Remove(Object value)
            {
                lock (_root)
                {
                    _list.Remove(value);
                }
            }

            public virtual void RemoveAt(int index)
            {
                lock (_root)
                {
                    _list.RemoveAt(index);
                }
            }
        }

        private class FixedSizeList : IList
        {
            private IList _list;

            internal FixedSizeList(IList l)
            {
                _list = l;
            }

            public virtual int Count
            {
                get { return _list.Count; }
            }

            public virtual bool IsReadOnly
            {
                get { return _list.IsReadOnly; }
            }

            public virtual bool IsFixedSize
            {
                get { return true; }
            }

            public virtual bool IsSynchronized
            {
                get { return _list.IsSynchronized; }
            }

            public virtual Object this[int index]
            {
                get
                {
                    return _list[index];
                }
                set
                {
                    _list[index] = value;
                }
            }

            public virtual Object SyncRoot
            {
                get { return _list.SyncRoot; }
            }

            public virtual int Add(Object obj)
            {
                throw new NotSupportedException("SR.NotSupported_FixedSizeCollection");
            }

            public virtual void Clear()
            {
                throw new NotSupportedException("SR.NotSupported_FixedSizeCollection");
            }

            public virtual bool Contains(Object obj)
            {
                return _list.Contains(obj);
            }

            public virtual void CopyTo(Array array, int index)
            {
                _list.CopyTo(array, index);
            }

            public virtual IEnumerator GetEnumerator()
            {
                return _list.GetEnumerator();
            }

            public virtual int IndexOf(Object value)
            {
                return _list.IndexOf(value);
            }

            public virtual void Insert(int index, Object obj)
            {
                throw new NotSupportedException("SR.NotSupported_FixedSizeCollection");
            }

            public virtual void Remove(Object value)
            {
                throw new NotSupportedException("SR.NotSupported_FixedSizeCollection");
            }

            public virtual void RemoveAt(int index)
            {
                throw new NotSupportedException("SR.NotSupported_FixedSizeCollection");
            }
        }

        private class FixedSizeArrayList : ArrayList
        {
            private ArrayList _list;

            internal FixedSizeArrayList(ArrayList l)
            {
                _list = l;
                _version = _list._version;
            }

            public override int Count
            {
                get { return _list.Count; }
            }

            public override bool IsReadOnly
            {
                get { return _list.IsReadOnly; }
            }

            public override bool IsFixedSize
            {
                get { return true; }
            }

            public override bool IsSynchronized
            {
                get { return _list.IsSynchronized; }
            }

            public override Object this[int index]
            {
                get
                {
                    return _list[index];
                }
                set
                {
                    _list[index] = value;
                    _version = _list._version;
                }
            }

            public override Object SyncRoot
            {
                get { return _list.SyncRoot; }
            }

            public override int Add(Object obj)
            {
                throw new NotSupportedException("SR.NotSupported_FixedSizeCollection");
            }

            public override void AddRange(ICollection c)
            {
                throw new NotSupportedException("SR.NotSupported_FixedSizeCollection");
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int BinarySearch(int index, int count, Object value, IComparer comparer)
            {
                return _list.BinarySearch(index, count, value, comparer);
            }

            public override int Capacity
            {
                get { return _list.Capacity; }
                //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
                set
                { throw new NotSupportedException("SR.NotSupported_FixedSizeCollection"); }
            }

            public override void Clear()
            {
                throw new NotSupportedException("SR.NotSupported_FixedSizeCollection");
            }

            public override Object Clone()
            {
                FixedSizeArrayList arrayList = new FixedSizeArrayList(_list);
                arrayList._list = (ArrayList)_list.Clone();
                return arrayList;
            }

            public override bool Contains(Object obj)
            {
                return _list.Contains(obj);
            }

            public override void CopyTo(Array array, int index)
            {
                _list.CopyTo(array, index);
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void CopyTo(int index, Array array, int arrayIndex, int count)
            {
                _list.CopyTo(index, array, arrayIndex, count);
            }

            public override IEnumerator GetEnumerator()
            {
                return _list.GetEnumerator();
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override IEnumerator GetEnumerator(int index, int count)
            {
                return _list.GetEnumerator(index, count);
            }

            public override int IndexOf(Object value)
            {
                return _list.IndexOf(value);
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int IndexOf(Object value, int startIndex)
            {
                return _list.IndexOf(value, startIndex);
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int IndexOf(Object value, int startIndex, int count)
            {
                return _list.IndexOf(value, startIndex, count);
            }

            public override void Insert(int index, Object obj)
            {
                throw new NotSupportedException("SR.NotSupported_FixedSizeCollection");
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void InsertRange(int index, ICollection c)
            {
                throw new NotSupportedException("SR.NotSupported_FixedSizeCollection");
            }

            public override int LastIndexOf(Object value)
            {
                return _list.LastIndexOf(value);
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int LastIndexOf(Object value, int startIndex)
            {
                return _list.LastIndexOf(value, startIndex);
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int LastIndexOf(Object value, int startIndex, int count)
            {
                return _list.LastIndexOf(value, startIndex, count);
            }

            public override void Remove(Object value)
            {
                throw new NotSupportedException("SR.NotSupported_FixedSizeCollection");
            }

            public override void RemoveAt(int index)
            {
                throw new NotSupportedException("SR.NotSupported_FixedSizeCollection");
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void RemoveRange(int index, int count)
            {
                throw new NotSupportedException("SR.NotSupported_FixedSizeCollection");
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void SetRange(int index, ICollection c)
            {
                _list.SetRange(index, c);
                _version = _list._version;
            }

            public override ArrayList GetRange(int index, int count)
            {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (Count - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                return new Range(this, index, count);
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void Reverse(int index, int count)
            {
                _list.Reverse(index, count);
                _version = _list._version;
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void Sort(int index, int count, IComparer comparer)
            {
                _list.Sort(index, count, comparer);
                _version = _list._version;
            }

            public override Object[] ToArray()
            {
                return _list.ToArray();
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override Array ToArray(Type type)
            {
                return _list.ToArray(type);
            }

            public override void TrimToSize()
            {
                throw new NotSupportedException("SR.NotSupported_FixedSizeCollection");
            }
        }

        private class ReadOnlyList : IList
        {
            private IList _list;

            internal ReadOnlyList(IList l)
            {
                _list = l;
            }

            public virtual int Count
            {
                get { return _list.Count; }
            }

            public virtual bool IsReadOnly
            {
                get { return true; }
            }

            public virtual bool IsFixedSize
            {
                get { return true; }
            }

            public virtual bool IsSynchronized
            {
                get { return _list.IsSynchronized; }
            }

            public virtual Object this[int index]
            {
                get
                {
                    return _list[index];
                }
                set
                {
                    throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
                }
            }

            public virtual Object SyncRoot
            {
                get { return _list.SyncRoot; }
            }

            public virtual int Add(Object obj)
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }

            public virtual void Clear()
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }

            public virtual bool Contains(Object obj)
            {
                return _list.Contains(obj);
            }

            public virtual void CopyTo(Array array, int index)
            {
                _list.CopyTo(array, index);
            }

            public virtual IEnumerator GetEnumerator()
            {
                return _list.GetEnumerator();
            }

            public virtual int IndexOf(Object value)
            {
                return _list.IndexOf(value);
            }

            public virtual void Insert(int index, Object obj)
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }

            public virtual void Remove(Object value)
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }

            public virtual void RemoveAt(int index)
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }
        }

        private class ReadOnlyArrayList : ArrayList
        {
            private ArrayList _list;

            internal ReadOnlyArrayList(ArrayList l)
            {
                _list = l;
            }

            public override int Count
            {
                get { return _list.Count; }
            }

            public override bool IsReadOnly
            {
                get { return true; }
            }

            public override bool IsFixedSize
            {
                get { return true; }
            }

            public override bool IsSynchronized
            {
                get { return _list.IsSynchronized; }
            }

            public override Object this[int index]
            {
                get
                {
                    return _list[index];
                }
                set
                {
                    throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
                }
            }

            public override Object SyncRoot
            {
                get { return _list.SyncRoot; }
            }

            public override int Add(Object obj)
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }

            public override void AddRange(ICollection c)
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int BinarySearch(int index, int count, Object value, IComparer comparer)
            {
                return _list.BinarySearch(index, count, value, comparer);
            }


            public override int Capacity
            {
                get { return _list.Capacity; }
                //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
                set
                { throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection"); }
            }

            public override void Clear()
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }

            public override Object Clone()
            {
                ReadOnlyArrayList arrayList = new ReadOnlyArrayList(_list);
                arrayList._list = (ArrayList)_list.Clone();
                return arrayList;
            }

            public override bool Contains(Object obj)
            {
                return _list.Contains(obj);
            }

            public override void CopyTo(Array array, int index)
            {
                _list.CopyTo(array, index);
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void CopyTo(int index, Array array, int arrayIndex, int count)
            {
                _list.CopyTo(index, array, arrayIndex, count);
            }

            public override IEnumerator GetEnumerator()
            {
                return _list.GetEnumerator();
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override IEnumerator GetEnumerator(int index, int count)
            {
                return _list.GetEnumerator(index, count);
            }

            public override int IndexOf(Object value)
            {
                return _list.IndexOf(value);
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int IndexOf(Object value, int startIndex)
            {
                return _list.IndexOf(value, startIndex);
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int IndexOf(Object value, int startIndex, int count)
            {
                return _list.IndexOf(value, startIndex, count);
            }

            public override void Insert(int index, Object obj)
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void InsertRange(int index, ICollection c)
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }

            public override int LastIndexOf(Object value)
            {
                return _list.LastIndexOf(value);
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int LastIndexOf(Object value, int startIndex)
            {
                return _list.LastIndexOf(value, startIndex);
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int LastIndexOf(Object value, int startIndex, int count)
            {
                return _list.LastIndexOf(value, startIndex, count);
            }

            public override void Remove(Object value)
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }

            public override void RemoveAt(int index)
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void RemoveRange(int index, int count)
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void SetRange(int index, ICollection c)
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }

            public override ArrayList GetRange(int index, int count)
            {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (Count - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                return new Range(this, index, count);
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void Reverse(int index, int count)
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void Sort(int index, int count, IComparer comparer)
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }

            public override Object[] ToArray()
            {
                return _list.ToArray();
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override Array ToArray(Type type)
            {
                return _list.ToArray(type);
            }

            public override void TrimToSize()
            {
                throw new NotSupportedException("SR.NotSupported_ReadOnlyCollection");
            }
        }


        // Implements an enumerator for a ArrayList. The enumerator uses the
        // internal version number of the list to ensure that no modifications are
        // made to the list while an enumeration is in progress.
        private sealed class ArrayListEnumerator : IEnumerator, ICloneable
        {
            private ArrayList _list;
            private int _index;
            private int _endIndex;       // Where to stop.
            private int _version;
            private Object _currentElement;
            private int _startIndex;     // Save this for Reset.

            internal ArrayListEnumerator(ArrayList list, int index, int count)
            {
                _list = list;
                _startIndex = index;
                _index = index - 1;
                _endIndex = _index + count;  // last valid index
                _version = list._version;
                _currentElement = null;
            }

            public object Clone()
            {

                return MemberwiseClone();

            }

            public bool MoveNext()
            {
                if (_version != _list._version) throw new InvalidOperationException("SR.InvalidOperation_EnumFailedVersion");
                if (_index < _endIndex)
                {
                    _currentElement = _list[++_index];
                    return true;
                }
                else
                {
                    _index = _endIndex + 1;
                }

                return false;
            }

            public Object Current
            {
                get
                {
                    if (_index < _startIndex)
                        throw new InvalidOperationException("SR.InvalidOperation_EnumNotStarted");
                    else if (_index > _endIndex)
                    {
                        throw new InvalidOperationException("SR.InvalidOperation_EnumEnded");
                    }
                    return _currentElement;
                }
            }

            public void Reset()
            {
                if (_version != _list._version) throw new InvalidOperationException("SR.InvalidOperation_EnumFailedVersion");
                _index = _startIndex - 1;
            }
        }

        // Implementation of a generic list subrange. An instance of this class
        // is returned by the default implementation of List.GetRange.
        private class Range : ArrayList
        {
            private ArrayList _baseList;
            private int _baseIndex;
            private int _baseSize;
            private int _baseVersion;

            internal Range(ArrayList list, int index, int count)
                : base(false)
            {
                _baseList = list;
                _baseIndex = index;
                _baseSize = count;
                _baseVersion = list._version;
                // we also need to update _version field to make Range of Range work
                _version = list._version;
            }

            private void InternalUpdateRange()
            {
                if (_baseVersion != _baseList._version)
                    throw new InvalidOperationException("SR.InvalidOperation_UnderlyingArrayListChanged");
            }

            private void InternalUpdateVersion()
            {
                _baseVersion++;
                _version++;
            }

            public override int Add(Object value)
            {
                InternalUpdateRange();
                _baseList.Insert(_baseIndex + _baseSize, value);
                InternalUpdateVersion();
                return _baseSize++;
            }

            public override void AddRange(ICollection c)
            {
                if (c == null)
                {
                    throw new ArgumentNullException("nameof(c)");
                }

                InternalUpdateRange();
                int count = c.Count;
                if (count > 0)
                {
                    _baseList.InsertRange(_baseIndex + _baseSize, c);
                    InternalUpdateVersion();
                    _baseSize += count;
                }
            }

            public override int BinarySearch(int index, int count, Object value, IComparer comparer)
            {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (_baseSize - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                InternalUpdateRange();

                int i = _baseList.BinarySearch(_baseIndex + index, count, value, comparer);
                if (i >= 0) return i - _baseIndex;
                return i + _baseIndex;
            }

            public override int Capacity
            {
                get
                {
                    return _baseList.Capacity;
                }

                set
                {
                    if (value < Count) throw new ArgumentOutOfRangeException("nameof(value)", "SR.ArgumentOutOfRange_SmallCapacity");
                }
            }


            public override void Clear()
            {
                InternalUpdateRange();
                if (_baseSize != 0)
                {
                    _baseList.RemoveRange(_baseIndex, _baseSize);
                    InternalUpdateVersion();
                    _baseSize = 0;
                }
            }

            public override Object Clone()
            {
                InternalUpdateRange();
                Range arrayList = new Range(_baseList, _baseIndex, _baseSize);
                arrayList._baseList = (ArrayList)_baseList.Clone();
                return arrayList;
            }

            public override bool Contains(Object item)
            {
                InternalUpdateRange();
                if (item == null)
                {
                    for (int i = 0; i < _baseSize; i++)
                        if (_baseList[_baseIndex + i] == null)
                            return true;
                    return false;
                }
                else
                {
                    for (int i = 0; i < _baseSize; i++)
                        if (_baseList[_baseIndex + i] != null && _baseList[_baseIndex + i].Equals(item))
                            return true;
                    return false;
                }
            }

            public override void CopyTo(Array array, int index)
            {
                if (array == null)
                    throw new ArgumentNullException("nameof(array)");
                if (array.Rank != 1)
                    throw new ArgumentException("SR.Arg_RankMultiDimNotSupported", "nameof(array)");
                if (index < 0)
                    throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (array.Length - index < _baseSize)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                InternalUpdateRange();
                _baseList.CopyTo(_baseIndex, array, index, _baseSize);
            }

            public override void CopyTo(int index, Array array, int arrayIndex, int count)
            {
                if (array == null)
                    throw new ArgumentNullException("nameof(array)");
                if (array.Rank != 1)
                    throw new ArgumentException("SR.Arg_RankMultiDimNotSupported", "nameof(array)");
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (array.Length - arrayIndex < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");
                if (_baseSize - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                InternalUpdateRange();
                _baseList.CopyTo(_baseIndex + index, array, arrayIndex, count);
            }

            public override int Count
            {
                get
                {
                    InternalUpdateRange();
                    return _baseSize;
                }
            }

            public override bool IsReadOnly
            {
                get { return _baseList.IsReadOnly; }
            }

            public override bool IsFixedSize
            {
                get { return _baseList.IsFixedSize; }
            }

            public override bool IsSynchronized
            {
                get { return _baseList.IsSynchronized; }
            }

            public override IEnumerator GetEnumerator()
            {
                return GetEnumerator(0, _baseSize);
            }

            public override IEnumerator GetEnumerator(int index, int count)
            {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (_baseSize - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                InternalUpdateRange();
                return _baseList.GetEnumerator(_baseIndex + index, count);
            }

            public override ArrayList GetRange(int index, int count)
            {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (_baseSize - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                InternalUpdateRange();
                return new Range(this, index, count);
            }

            public override Object SyncRoot
            {
                get
                {
                    return _baseList.SyncRoot;
                }
            }


            public override int IndexOf(Object value)
            {
                InternalUpdateRange();
                int i = _baseList.IndexOf(value, _baseIndex, _baseSize);
                if (i >= 0) return i - _baseIndex;
                return -1;
            }

            public override int IndexOf(Object value, int startIndex)
            {
                if (startIndex < 0)
                    throw new ArgumentOutOfRangeException("nameof(startIndex)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (startIndex > _baseSize)
                    throw new ArgumentOutOfRangeException("nameof(startIndex)", "SR.ArgumentOutOfRange_Index");

                InternalUpdateRange();
                int i = _baseList.IndexOf(value, _baseIndex + startIndex, _baseSize - startIndex);
                if (i >= 0) return i - _baseIndex;
                return -1;
            }

            public override int IndexOf(Object value, int startIndex, int count)
            {
                if (startIndex < 0 || startIndex > _baseSize)
                    throw new ArgumentOutOfRangeException("nameof(startIndex)", "SR.ArgumentOutOfRange_Index");

                if (count < 0 || (startIndex > _baseSize - count))
                    throw new ArgumentOutOfRangeException("nameof(count)", "SR.ArgumentOutOfRange_Count");

                InternalUpdateRange();
                int i = _baseList.IndexOf(value, _baseIndex + startIndex, count);
                if (i >= 0) return i - _baseIndex;
                return -1;
            }

            public override void Insert(int index, Object value)
            {
                if (index < 0 || index > _baseSize) throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_Index");

                InternalUpdateRange();
                _baseList.Insert(_baseIndex + index, value);
                InternalUpdateVersion();
                _baseSize++;
            }

            public override void InsertRange(int index, ICollection c)
            {
                if (index < 0 || index > _baseSize) throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_Index");
                if (c == null)
                {
                    throw new ArgumentNullException("nameof(c)");
                }

                InternalUpdateRange();
                int count = c.Count;
                if (count > 0)
                {
                    _baseList.InsertRange(_baseIndex + index, c);
                    _baseSize += count;
                    InternalUpdateVersion();
                }
            }

            public override int LastIndexOf(Object value)
            {
                InternalUpdateRange();
                int i = _baseList.LastIndexOf(value, _baseIndex + _baseSize - 1, _baseSize);
                if (i >= 0) return i - _baseIndex;
                return -1;
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int LastIndexOf(Object value, int startIndex)
            {
                return LastIndexOf(value, startIndex, startIndex + 1);
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override int LastIndexOf(Object value, int startIndex, int count)
            {
                InternalUpdateRange();
                if (_baseSize == 0)
                    return -1;

                if (startIndex >= _baseSize)
                    throw new ArgumentOutOfRangeException("nameof(startIndex)", "SR.ArgumentOutOfRange_Index");
                if (startIndex < 0)
                    throw new ArgumentOutOfRangeException("nameof(startIndex)", "SR.ArgumentOutOfRange_NeedNonNegNum");

                int i = _baseList.LastIndexOf(value, _baseIndex + startIndex, count);
                if (i >= 0) return i - _baseIndex;
                return -1;
            }

            // Don't need to override Remove

            public override void RemoveAt(int index)
            {
                if (index < 0 || index >= _baseSize) throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_Index");

                InternalUpdateRange();
                _baseList.RemoveAt(_baseIndex + index);
                InternalUpdateVersion();
                _baseSize--;
            }

            public override void RemoveRange(int index, int count)
            {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (_baseSize - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                InternalUpdateRange();
                // No need to call _bastList.RemoveRange if count is 0.
                // In addition, _baseList won't change the version number if count is 0. 
                if (count > 0)
                {
                    _baseList.RemoveRange(_baseIndex + index, count);
                    InternalUpdateVersion();
                    _baseSize -= count;
                }
            }

            public override void Reverse(int index, int count)
            {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (_baseSize - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                InternalUpdateRange();
                _baseList.Reverse(_baseIndex + index, count);
                InternalUpdateVersion();
            }

            //[SuppressMessage("Microsoft.Contracts", "CC1055")]  // Skip extra error checking to avoid *potential* AppCompat problems.
            public override void SetRange(int index, ICollection c)
            {
                InternalUpdateRange();
                if (index < 0 || index >= _baseSize) throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_Index");
                _baseList.SetRange(_baseIndex + index, c);
                if (c.Count > 0)
                {
                    InternalUpdateVersion();
                }
            }

            public override void Sort(int index, int count, IComparer comparer)
            {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException(index < 0 ? "nameof(index)" : "nameof(count)", "SR.ArgumentOutOfRange_NeedNonNegNum");
                if (_baseSize - index < count)
                    throw new ArgumentException("SR.Argument_InvalidOffLen");

                InternalUpdateRange();
                _baseList.Sort(_baseIndex + index, count, comparer);
                InternalUpdateVersion();
            }

            public override Object this[int index]
            {
                get
                {
                    InternalUpdateRange();
                    if (index < 0 || index >= _baseSize) throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_Index");
                    return _baseList[_baseIndex + index];
                }
                set
                {
                    InternalUpdateRange();
                    if (index < 0 || index >= _baseSize) throw new ArgumentOutOfRangeException("nameof(index)", "SR.ArgumentOutOfRange_Index");
                    _baseList[_baseIndex + index] = value;
                    InternalUpdateVersion();
                }
            }

            public override Object[] ToArray()
            {
                InternalUpdateRange();
                if (_baseSize == 0)
                    return EmptyArray<Object>.Value;
                Object[] array = new Object[_baseSize];
                Array.Copy(_baseList._items, _baseIndex, array, 0, _baseSize);
                return array;
            }

            public override Array ToArray(Type type)
            {
                if (type == null)
                    throw new ArgumentNullException("nameof(type)");

                InternalUpdateRange();
                Array array = Array.CreateInstance(type, _baseSize);
                _baseList.CopyTo(_baseIndex, array, 0, _baseSize);
                return array;
            }

            public override void TrimToSize()
            {
                throw new NotSupportedException("SR.NotSupported_RangeCollection");
            }
        }

        private sealed class ArrayListEnumeratorSimple : IEnumerator, ICloneable
        {
            private ArrayList _list;
            private int _index;
            private int _version;
            private Object _currentElement;
            private bool _isArrayList;
            // this object is used to indicate enumeration has not started or has terminated
            private static Object s_dummyObject = new Object();

            internal ArrayListEnumeratorSimple(ArrayList list)
            {
                _list = list;
                _index = -1;
                _version = list._version;
                _isArrayList = (list.GetType() == typeof(ArrayList));
                _currentElement = s_dummyObject;
            }

            public object Clone()
            {
                return MemberwiseClone();
            }
            public bool MoveNext()
            {
                if (_version != _list._version)
                {
                    throw new InvalidOperationException("SR.InvalidOperation_EnumFailedVersion");
                }

                if (_isArrayList)
                {  // avoid calling virtual methods if we are operating on ArrayList to improve performance
                    if (_index < _list._size - 1)
                    {
                        _currentElement = _list._items[++_index];
                        return true;
                    }
                    else
                    {
                        _currentElement = s_dummyObject;
                        _index = _list._size;
                        return false;
                    }
                }
                else
                {
                    if (_index < _list.Count - 1)
                    {
                        _currentElement = _list[++_index];
                        return true;
                    }
                    else
                    {
                        _index = _list.Count;
                        _currentElement = s_dummyObject;
                        return false;
                    }
                }
            }

            public Object Current
            {
                get
                {
                    object temp = _currentElement;
                    if (s_dummyObject == temp)
                    { // check if enumeration has not started or has terminated
                        if (_index == -1)
                        {
                            throw new InvalidOperationException("SR.InvalidOperation_EnumNotStarted");
                        }
                        else
                        {
                            throw new InvalidOperationException("SR.InvalidOperation_EnumEnded");
                        }
                    }

                    return temp;
                }
            }

            public void Reset()
            {
                if (_version != _list._version)
                {
                    throw new InvalidOperationException("SR.InvalidOperation_EnumFailedVersion");
                }

                _currentElement = s_dummyObject;
                _index = -1;
            }
        }

        internal class ArrayListDebugView
        {
            private ArrayList _arrayList;

            public ArrayListDebugView(ArrayList arrayList)
            {
                if (arrayList == null)
                    throw new ArgumentNullException("nameof(arrayList)");

                _arrayList = arrayList;
            }

            //[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
            public Object[] Items
            {
                get
                {
                    return _arrayList.ToArray();
                }
            }
        }

        /* Angello's Code */
        public string ToStringForInt()
        {
            string ret = "{";


            var en = this.GetEnumerator();
            while (en.MoveNext())
            {
                ret += en.Current.ToString() + " ";
            }

            return ret + "}";
        }
    }
}
]]></source>
</chunk>
</document>
<document src="d:\MultiLearnerPrecondition\BenchmarksAll\DataStructures\DataStructuresTest\Factories\ArrayListFactory.cs" renderPrefix="s1"><chunk hits="-1" domain="unknown"><source><![CDATA[using System;

using System.Text;
using Microsoft.Pex.Framework;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace DataStructures.Test.Factories
{
    
    public static class ArrayListFactory
    {
        [PexFactoryMethod(typeof(DataStructures.ArrayList))]
        public static DataStructures.ArrayList Create([PexAssumeNotNull]int[] elems)
        ]]></source>
</chunk>
<method name="Create" namespace="DataStructures.Test.Factories" type="DataStructures.Test.Factories.ArrayListFactory" typeName="ArrayListFactory" token="6000043" module="DataStructuresTest.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="9" coveredRatio="0"/>
</method>
<chunk hits="0" offset="000d" domain="userortestcode"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="000e" domain="userortestcode"><source><![CDATA[PexAssume.IsTrue( elems.Length < 11);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0020" domain="userortestcode"><source><![CDATA[PexAssume.TrueForAll(0, elems.Length, _i => ]]></source>
</chunk>
<method name="&lt;Create&gt;b__0" namespace="DataStructures.Test.Factories" type="DataStructures.Test.Factories.ArrayListFactory+&lt;&gt;c__DisplayClass1" typeName="ArrayListFactory+&lt;&gt;c__DisplayClass1" token="600006b" module="DataStructuresTest.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="3" coveredRatio="0"/>
</method>
<chunk hits="0" offset="0000" domain="userortestcode"><source><![CDATA[elems[_i] > -11 && elems[_i] < 11]]></source>
</chunk>
<chunk hits="0" offset="0020" domain="userortestcode"><source><![CDATA[);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="003b" domain="userortestcode"><source><![CDATA[DataStructures.ArrayList ret = new DataStructures.ArrayList(elems.Length+2);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            
            for (]]></source>
</chunk>
<chunk hits="0" offset="004b" domain="userortestcode"><source><![CDATA[int i = 0;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="0069" domain="userortestcode"><source><![CDATA[i < elems.Length]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[; ]]></source>
</chunk>
<chunk hits="0" offset="0065" domain="userortestcode"><source><![CDATA[i++]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[)
            ]]></source>
</chunk>
<chunk hits="0" offset="004f" domain="userortestcode"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                //if (!ret.Contains(elems[i]))
                    ]]></source>
</chunk>
<chunk hits="0" offset="0050" domain="userortestcode"><source><![CDATA[ret.Add(elems[i]);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0064" domain="userortestcode"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            
            ]]></source>
</chunk>
<chunk hits="0" offset="007a" domain="userortestcode"><source><![CDATA[return ret;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        ]]></source>
</chunk>
<chunk hits="0" offset="007e" domain="userortestcode"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
    }
}
]]></source>
</chunk>
</document>
<document src="d:\MultiLearnerPrecondition\BenchmarksAll\DataStructures\DataStructuresTest\ArrayListTest.cs" renderPrefix="s2"><chunk hits="-1" domain="unknown"><source><![CDATA[// <copyright file="ArrayListTest.cs">Copyright ©  2018</copyright>
using System;
using System.Collections;
using DataStructures;
using Microsoft.Pex.Framework;
using Microsoft.Pex.Framework.Validation;
using Microsoft.Pex.Framework.Settings;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using PexAPIWrapper;
using DataStructures.Utility;

namespace DataStructures.Test
{
    /// <summary>This class contains parameterized unit tests for ArrayList</summary>
    [PexClass(typeof(ArrayList))]
    //[PexAllowedExceptionFromTypeUnderTest(typeof(InvalidOperationException))]
    //[PexAllowedExceptionFromTypeUnderTest(typeof(ArgumentException), AcceptExceptionSubtypes = true)]
    [TestClass]
    public partial class ArrayListTest
    {


        /// <summary>Test stub for Add(Object)</summary>
        //[PexMethod(TestEmissionFilter = PexTestEmissionFilter.All)]
        [PexMethod]
        public void PUT_CommutativityAddAdd([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);

            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));



            AssumePrecondition.IsTrue(!(true));

            int a1 = -1, ad1 = -1;
            int a2 = -1, ad2 = -1;

            //First Test
            a1 = s1.Add(x);
            ad1 = s1.Add(y);

            //Second Test
            ad2 = s2.Add(y);
            a2 = s2.Add(x);


            NotpAssume.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));
            PexAssert.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));
        }

        //[PexMethod(TestEmissionFilter = PexTestEmissionFilter.All)]
        [PexMethod]
        public void PUT_CommutativityAddContains([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        ]]></source>
</chunk>
<method name="PUT_CommutativityAddContains" namespace="DataStructures.Test" type="DataStructures.Test.ArrayListTest" typeName="ArrayListTest" token="6000002" module="DataStructuresTest.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="6" value="1"/>
<hit index="7" value="1"/>
<hit index="8" value="1"/>
<hit index="9" value="1"/>
<hit index="10" value="1"/>
<hit index="11" value="1"/>
<hit index="12" value="1"/>
<hit index="13" value="1"/>
<hit index="14" value="1"/>
<hit index="15" value="1"/>
<hit index="16" value="2"/>
<hit index="17" value="1"/>
<hit index="18" value="1"/>
<hit index="19" value="1"/>
<hit index="20" value="1"/>
<hit index="21" value="1"/>
<hit index="22" value="1"/>
<hit index="23" value="1"/>
<hit index="24" value="1"/>
<hit index="25" value="1"/>
<hit index="26" value="1"/>
<hit index="27" value="2"/>
<hit index="28" value="1"/>
<hit index="29" value="1"/>
<hit index="30" value="1"/>
<hit index="31" value="1"/>
<hit index="32" value="1"/>
<hit index="33" value="1"/>
<hit index="34" value="2"/>
<hit index="35" value="1"/>
<hit index="36" value="1"/>
<hit index="37" value="1"/>
<hit index="38" value="1"/>
<hit index="39" value="1"/>
<hit index="40" value="1"/>
<hit index="41" value="2"/>
<hit index="42" value="1"/>
<hit index="43" value="1"/>
<hit index="44" value="1"/>
<hit index="45" value="1"/>
<hit index="46" value="1"/>
<hit index="47" value="1"/>
<hit index="48" value="2"/>
<hit index="49" value="1"/>
<hit index="50" value="1"/>
<hit index="51" value="1"/>
<hit index="52" value="1"/>
<hit index="53" value="1"/>
<hit index="54" value="1"/>
<hit index="55" value="2"/>
<hit index="56" value="1"/>
<hit index="57" value="1"/>
<hit index="58" value="1"/>
<hit index="59" value="1"/>
<hit index="60" value="1"/>
<hit index="61" value="1"/>
<hit index="62" value="2"/>
<hit index="63" value="1"/>
<hit index="64" value="1"/>
<hit index="65" value="1"/>
<hit index="66" value="1"/>
<hit index="67" value="1"/>
<hit index="68" value="1"/>
<hit index="69" value="1"/>
<hit index="70" value="1"/>
<hit index="71" value="2"/>
<hit index="72" value="1"/>
<hit index="73" value="1"/>
<hit index="74" value="1"/>
<hit index="75" value="1"/>
<hit index="76" value="2"/>
<hit index="77" value="1"/>
<hit index="78" value="1"/>
<hit index="79" value="1"/>
<hit index="80" value="1"/>
<hit index="81" value="2"/>
<hit index="82" value="1"/>
<hit index="83" value="1"/>
<hit index="84" value="1"/>
<hit index="85" value="1"/>
<hit index="86" value="2"/>
<hit index="87" value="1"/>
<hit index="88" value="1"/>
<hit index="89" value="1"/>
<hit index="90" value="1"/>
<hit index="91" value="1"/>
<hit index="92" value="2"/>
<hit index="93" value="1"/>
<hit index="94" value="1"/>
<hit index="98" value="1"/>
<hit index="100" value="1"/>
</hits>
<coverage domain="userortestcode" unit="block" covered="33" total="35" coveredRatio="0.94285714285714284"/>
</method>
<chunk hits="1" offset="0000" domain="userortestcode"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="userortestcode"><source><![CDATA[DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0008" domain="userortestcode"><source><![CDATA[ArrayListEqualityComparer eq = new ArrayListEqualityComparer();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            ]]></source>
</chunk>
<chunk hits="1" offset="000e" domain="userortestcode"><source><![CDATA[PexAssume.IsTrue(x > -11 && x < 11);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0022" domain="userortestcode"><source><![CDATA[PexAssume.IsTrue(y > -11 && y < 11);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            ]]></source>
</chunk>
<chunk hits="1" offset="0036" domain="userortestcode"><source><![CDATA[PexObserve.ValueForViewing("$input_s1.Count", s1.Count);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0047" domain="userortestcode"><source><![CDATA[PexObserve.ValueForViewing("$input_x", x);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0053" domain="userortestcode"><source><![CDATA[PexObserve.ValueForViewing("$input_y", y);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="005f" domain="userortestcode"><source><![CDATA[PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0076" domain="userortestcode"><source><![CDATA[PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="008d" domain="userortestcode"><source><![CDATA[PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="00a4" domain="userortestcode"><source><![CDATA[PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="00bb" domain="userortestcode"><source><![CDATA[PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="00d2" domain="userortestcode"><source><![CDATA[PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            ]]></source>
</chunk>
<chunk hits="1" offset="00e9" domain="userortestcode"><source><![CDATA[AssumePrecondition.IsTrue(true);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="00f0" domain="userortestcode"><source><![CDATA[int a1 = -1,]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="1" offset="00f2" domain="userortestcode"><source><![CDATA[a2 = -1;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="00f4" domain="userortestcode"><source><![CDATA[bool ad1 = false,]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="1" offset="00f7" domain="userortestcode"><source><![CDATA[ad2 = false;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            //First Test
            ]]></source>
</chunk>
<chunk hits="1" offset="00fa" domain="userortestcode"><source><![CDATA[a1 = s1.Add(x);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="3" offset="0107" domain="userortestcode"><source><![CDATA[ad1 = s1.Contains(y);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            //Second Test
            ]]></source>
</chunk>
<chunk hits="3" offset="0115" domain="userortestcode"><source><![CDATA[ad2 = s2.Contains(y);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="3" offset="0123" domain="userortestcode"><source><![CDATA[a2 = s2.Add(x);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[


            //NotpAssume.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));
            ]]></source>
</chunk>
<chunk hits="3" offset="0130" domain="userortestcode"><source><![CDATA[PexAssert.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="014c" domain="userortestcode"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        //[PexMethod(TestEmissionFilter = PexTestEmissionFilter.All)]
        [PexMethod]
        public void PUT_CommutativityAddCount([PexAssumeUnderTest] DataStructures.ArrayList s1, int x)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            AssumePrecondition.IsTrue(  false);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;

            //First Test
            a1 = s1.Add(x);
            ad1 = s1.Count;

            //Second Test
            ad2 = s2.Count;
            a2 = s2.Add(x);

            NotpAssume.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));
            PexAssert.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));
        }


        //[PexMethod(TestEmissionFilter = PexTestEmissionFilter.All)]
        [PexMethod]
        public void PUT_CommutativityAddGet([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);


            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(  ((!(y <= -1)) && ((-s1.Count + y <= -1))) );

            int a1 = -1, a2 = -1;
            Object ad1 = -1, ad2 = -1;
            
            
                //First Test
                a1 = s1.Add(x);
                ad1 = s1[y]; //this is how you write the method get
            
                //Second Test
                ad2 = s2[y]; //this is how you write the method get
                a2 = s2.Add(x);

            NotpAssume.IsTrue((a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2)));            
            PexAssert.IsTrue( (a1 == a2 && ad1.Equals(ad2) && eq.Equals(s1, s2)));
        }

        //[PexMethod(TestEmissionFilter = PexTestEmissionFilter.All)]
        [PexMethod]
        public void PUT_CommutativityAddIndexOf([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);

            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue((( false )));

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;

            //First Test
            a1 = s1.Add(x);
            ad1 = s1.IndexOf(y);

            //Second Test
            ad2 = s2.IndexOf(y);
            a2 = s2.Add(x);

            NotpAssume.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));
            PexAssert.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));


        }

        //[PexMethod(TestEmissionFilter = PexTestEmissionFilter.All)]
        [PexMethod]
        public void PUT_CommutativityAddInsert([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y, int y1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexAssume.IsTrue(y1 > -101 && y1 < 101);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_y1", y1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y1)", s1.IndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y1)", s1.LastIndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y1)", s1.Contains(y1));
            AssumePrecondition.IsTrue(  false);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;

            //First Test
            a1 = s1.Add(x);
            s1.Insert(y, y1);

            //Second Test
            s2.Insert(y, y1);
            a2 = s2.Add(x);

            NotpAssume.IsTrue(a1 == a2 && eq.Equals(s1, s2));
            PexAssert.IsTrue(a1 == a2 && eq.Equals(s1, s2));
        }

        //[PexMethod(TestEmissionFilter = PexTestEmissionFilter.All)]
        [PexMethod]
        public void PUT_CommutativityAddLastIndexOf([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(  ((!(x == y))) );

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;

            //First Test
            a1 = s1.Add(x);
            ad1 = s1.LastIndexOf(y);

            //Second Test
            ad2 = s2.LastIndexOf(y);
            a2 = s2.Add(x);

            NotpAssume.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));
            PexAssert.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));

        }

        //[PexMethod(TestEmissionFilter = PexTestEmissionFilter.All)]
        [PexMethod]
        public void PUT_CommutativityAddRemove([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue((( false )));

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;

            //First Test
            a1 = s1.Add(x);
            s1.Remove(y);

            //Second Test
            s2.Remove(y);
            a2 = s2.Add(x);

            NotpAssume.IsTrue(a1 == a2 && eq.Equals(s1, s2));
            PexAssert.IsTrue(a1 == a2 && eq.Equals(s1, s2));

        }

        //[PexMethod(TestEmissionFilter = PexTestEmissionFilter.All)]
        [PexMethod]
        public void PUT_CommutativityAddRemoveAt([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);

            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            
            AssumePrecondition.IsTrue(  true);

            int a1 = -1, a2 = -1;

            
            //First Test
            a1 = s1.Add(x);
            s1.RemoveAt(y);
            
            //Second Test
            s2.RemoveAt(y);
            a2 = s2.Add(x);

            //NotpAssume.IsTrue((a1 == a2 && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((a1 == a2 && eq.Equals(s1, s2)));

        }

        //[PexMethod(TestEmissionFilter = PexTestEmissionFilter.All)]
        [PexMethod]
        public void PUT_CommutativityAddSet([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y, int y1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexAssume.IsTrue(y1 > -11 && y1 < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_y1", y1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y1)", s1.IndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y1)", s1.LastIndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y1)", s1.Contains(y1));
            AssumePrecondition.IsTrue(!(true));

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            
            
                //First Test
                a1 = s1.Add(x);
                s1[y] = y1;
            
                //Second Test
                s2[y] = y1;
                a2 = s2.Add(x);

            NotpAssume.IsTrue((a1 == a2 && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((a1 == a2 && eq.Equals(s1, s2)));

        }



        [PexMethod]
        public void PUT_CommutativityContainsContains([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();
            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            bool a1 = false, a2 = false;
            bool ad1 = false, ad2 = false;


            //First Test
            a1 = s1.Contains(x);
            ad1 = s1.Contains(y);

            //Second Test
            ad2 = s2.Contains(y);
            a2 = s2.Contains(x);

            //NotpAssume.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));
            PexAssert.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));
        }

        [PexMethod]
        public void PUT_CommutativityContainsCount([PexAssumeUnderTest] DataStructures.ArrayList s1, int x)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();
            PexAssume.IsTrue(x > -11 && x < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            AssumePrecondition.IsTrue(true);

            bool a1 = false, a2 = false;
            int ad1 = -1, ad2 = -1;


            //First Test
            a1 = s1.Contains(x);
            ad1 = s1.Count;

            //Second Test
            ad2 = s2.Count;
            a2 = s2.Contains(x);

            //NotpAssume.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));
            PexAssert.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));
        }
        [PexMethod]
        public void PUT_CommutativityContainsGet([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            bool a1 = false, a2 = false;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;
            try
            {
                //First Test
                a1 = s1.Contains(x);
                ad1 = (int)s1[y];
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }

            try
            {
                //Second Test
                ad2 = (int)s2[y];
                a2 = s2.Contains(x);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }

            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2)));
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2)));

        }



        [PexMethod]
        public void PUT_CommutativityContainsIndexOf([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            bool a1 = false, a2 = false;
            int ad1 = -1, ad2 = -1;


            //First Test
            a1 = s1.Contains(x);
            ad1 = s1.IndexOf(y);

            //Second Test
            ad2 = s2.IndexOf(y);
            a2 = s2.Contains(x);

            //NotpAssume.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));
            PexAssert.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));
        }

        [PexMethod]
        public void PUT_CommutativityContainsInsert([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y, int y1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexAssume.IsTrue(y1 > -101 && y1 < 101);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_y1", y1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y1)", s1.IndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y1)", s1.LastIndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y1)", s1.Contains(y1));
            AssumePrecondition.IsTrue(true);

            bool a1 = false, a2 = false;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;
            try
            {
                //First Test
                a1 = s1.Contains(x);
                s1.Insert(y, y1);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2.Insert(y, y1);
                a2 = s2.Contains(x);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first & !second && a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first & !second && a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2)));

        }
        [PexMethod]
        public void PUT_CommutativityContainsRemove([PexAssumeUnderTest]  DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            bool a1 = false, a2 = false;
            int ad1 = -1, ad2 = -1;


            //First Test
            a1 = s1.Contains(x);
            s1.Remove(y);

            //Second Test
            s2.Remove(y);
            a2 = s2.Contains(x);

            //NotpAssume.IsTrue(a1 == a2 && eq.Equals(s1, s2));
            PexAssert.IsTrue(a1 == a2 && eq.Equals(s1, s2));

        }

        [PexMethod]
        public void PUT_CommutativityContainsRemoveAt([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            bool a1 = false, a2 = false;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                a1 = s1.Contains(x);
                s1.RemoveAt(y);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2.RemoveAt(y);
                a2 = s2.Contains(x);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }

            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityContainsSet([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y, int y1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexAssume.IsTrue(y1 > -101 && y1 < 101);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_y1", y1);
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y1)", s1.Contains(y1));
            AssumePrecondition.IsTrue(true);

            bool a1 = false, a2 = false;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                a1 = s1.Contains(x);
                s1[y] = y1;
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2[y] = y1;
                a2 = s2.Contains(x);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second & a1 == a2 && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second & a1 == a2 && eq.Equals(s1, s2)));
        }



        [PexMethod]
        public void PUT_CommutativityCountCount([PexAssumeUnderTest]DataStructures.ArrayList s1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            AssumePrecondition.IsTrue(true);


            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;


            //First Test
            a1 = s1.Count;
            ad1 = s1.Count;

            //Second Test
            ad2 = s2.Count;
            a2 = s2.Count;
            //NotpAssume.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));            
            PexAssert.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));

        }

        [PexMethod]
        public void PUT_CommutativityCountGet([PexAssumeUnderTest] DataStructures.ArrayList s1, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                a1 = s1.Count;
                ad1 = (int)s1[y];
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                ad2 = (int)s2[y];
                a2 = s2.Count;
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityCountIndexOf([PexAssumeUnderTest] DataStructures.ArrayList s1, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;


            //First Test
            a1 = s1.Count;
            ad1 = s1.IndexOf(y);

            //Second Test
            ad2 = s2.IndexOf(y);
            a2 = s2.Count;
            //NotpAssume.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));            
            PexAssert.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));

        }

        [PexMethod]
        public void PUT_CommutativityCountInsert([PexAssumeUnderTest] DataStructures.ArrayList s1, int y, int y1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(y > -11 && y < 11);
            PexAssume.IsTrue(y1 > -101 && y1 < 101);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_y1", y1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y1)", s1.IndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y1)", s1.LastIndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y1)", s1.Contains(y1));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                a1 = s1.Count;
                s1.Insert(y, y1);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }

            try
            {
                //Second Test
                s2.Insert(y, y1);
                a2 = s2.Count;
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }

            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityCountLastIndexOf([PexAssumeUnderTest] DataStructures.ArrayList s1, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;


            //First Test
            a1 = s1.Count;
            ad1 = s1.LastIndexOf(y);

            //Second Test
            ad2 = s2.LastIndexOf(y);
            a2 = s2.Count;
            //NotpAssume.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));            
            PexAssert.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));

        }

        [PexMethod]
        public void PUT_CommutativityCountRemove([PexAssumeUnderTest] DataStructures.ArrayList s1, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;


            //First Test
            a1 = s1.Count;
            s1.Remove(y);

            //Second Test
            s2.Remove(y);
            a2 = s2.Count;
            //NotpAssume.IsTrue(a1 == a2 && eq.Equals(s1, s2));            
            PexAssert.IsTrue(a1 == a2 && eq.Equals(s1, s2));

        }

        [PexMethod]
        public void PUT_CommutativityCountRemoveAt([PexAssumeUnderTest] DataStructures.ArrayList s1, int x)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                a1 = s1.Count;
                s1.RemoveAt(x);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2.RemoveAt(x);
                a2 = s2.Count;
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityCountSet([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y, int y1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexAssume.IsTrue(y1 > -101 && y1 < 101);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_y1", y1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y1)", s1.IndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y1)", s1.LastIndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y1)", s1.Contains(y1));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                a1 = s1.Count;
                s1[y] = y1;
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }

            try
            {
                //Second Test
                s2[y] = y1;
                a2 = s2.Count;
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }

            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityGetGet([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                a1 = (int)s1[x];
                ad1 = (int)s1[y];
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                ad2 = (int)s2[y];
                a2 = (int)s2[x];
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }

            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2)));
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityGetIndexof([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = true, second = false;
            try
            {
                //First Test
                a1 = (int)s1[x];
                ad1 = s1.IndexOf(y);
            }
            catch (ArgumentOutOfRangeException)
            {

                first = true;
            }
            try
            {
                //Second Test
                ad2 = s2.IndexOf(y);
                a2 = (int)s2[x];
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }

            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2)));
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityGetInsert([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y, int y1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexAssume.IsTrue(y1 > -101 && y1 < 101);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_y1", y1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y1)", s1.IndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y1)", s1.LastIndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y1)", s1.Contains(y1));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                a1 = (int)s1[x];
                s1.Insert(y, y1);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2.Insert(y, y1);
                a2 = (int)s2[x];
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityGetLastIndexOf([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                a1 = (int)s1[x];
                ad1 = s1.LastIndexOf(y);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                ad2 = s2.LastIndexOf(y);
                a2 = (int)s2[x];
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityGetRemove([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                a1 = (int)s1[x];
                s1.Remove(y);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2.Remove(y);
                a2 = (int)s2[x];
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }

            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityGetRemoveAt([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;
            try
            {
                //First Test
                a1 = (int)s1[x];
                s1.RemoveAt(y);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }

            try
            {
                //Second Test
                s2.RemoveAt(y);
                a2 = (int)s2[x];
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }

            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));

        }



        [PexMethod]
        public void PUT_CommutativityGetSet([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y, int y1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexAssume.IsTrue(y1 > -101 && y1 < 101);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_y1", y1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y1)", s1.IndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y1)", s1.LastIndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y1)", s1.Contains(y1));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                a1 = (int)s1[x];
                s1[y] = y1;
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2[y] = y1;
                a2 = (int)s2[x];
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityIndexOfIndexOf([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;


            //First Test
            a1 = s1.IndexOf(x);
            ad1 = s1.IndexOf(y);

            //Second Test
            ad2 = s2.IndexOf(y);
            a2 = s2.IndexOf(x);
            //NotpAssume.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));            
            PexAssert.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));

        }

        [PexMethod]
        public void PUT_CommutativityIndexOfInsert([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y, int y1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexAssume.IsTrue(y1 > -101 && y1 < 101);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_y1", y1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y1)", s1.IndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y1)", s1.LastIndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y1)", s1.Contains(y1));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;
            try
            {
                //First Test
                a1 = s1.IndexOf(x);
                s1.Insert(y, y1);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2.Insert(y, y1);
                a2 = s2.IndexOf(x);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityIndexOfLastIndexOf([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;


            //First Test
            a1 = s1.IndexOf(x);
            ad1 = s1.LastIndexOf(y);

            //Second Test
            ad2 = s2.LastIndexOf(y);
            a2 = s2.IndexOf(x);
            //NotpAssume.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));            
            PexAssert.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));

        }

        [PexMethod]
        public void PUT_CommutativityIndexOfRemove([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;


            //First Test
            a1 = s1.IndexOf(x);
            s1.Remove(y);

            //Second Test
            s2.Remove(y);
            a2 = s2.IndexOf(x);
            //NotpAssume.IsTrue(a1 == a2 && eq.Equals(s1, s2));            
            PexAssert.IsTrue(a1 == a2 && eq.Equals(s1, s2));

        }

        [PexMethod]
        public void PUT_CommutativityIndexOfRemoveAt([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                a1 = s1.IndexOf(x);
                s1.RemoveAt(y);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2.RemoveAt(y);
                a2 = s2.IndexOf(x);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityIndexOfSet([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y, int y1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexAssume.IsTrue(y1 > -101 && y1 < 101);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_y1", y1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y1)", s1.IndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y1)", s1.LastIndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y1)", s1.Contains(y1));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                a1 = s1.IndexOf(x);
                s1[y] = y1;
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }

            try
            {
                //Second Test
                s1[y] = y1;
                a2 = s2.IndexOf(x);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }

            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityInsertInsert([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int x1, int y, int y1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(x1 > -101 && x1 < 101);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexAssume.IsTrue(y1 > -101 && y1 < 101);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_x1", x1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x1)", s1.IndexOf(x1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x1)", s1.LastIndexOf(x1));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_y1", y1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y1)", s1.IndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y1)", s1.LastIndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(x1)", s1.Contains(x1));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y1)", s1.Contains(y1));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;
            try
            {
                //First Test
                s1.Insert(x, x1);
                s1.Insert(y, y1);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2.Insert(y, y1);
                s2.Insert(x, x1);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityInsertLastIndexOf([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int x1, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(x1 > -101 && x1 < 101);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_x1", x1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x1)", s1.IndexOf(x1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x1)", s1.LastIndexOf(x1));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(x1)", s1.Contains(x1));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;
            try
            {
                //First Test
                s1.Insert(x, x1);
                ad1 = s1.LastIndexOf(y);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                ad2 = s2.LastIndexOf(y);
                s2.Insert(x, x1);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && ad1 == ad2 && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && ad1 == ad2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityInsertRemove([PexAssumeUnderTest]  DataStructures.ArrayList s1, int x, int x1, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(x1 > -101 && x1 < 101);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_x1", x1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x1)", s1.IndexOf(x1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x1)", s1.LastIndexOf(x1));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(x1)", s1.Contains(x1));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;
            try
            {
                //First Test
                s1.Insert(x, x1);
                s1.Remove(y);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2.Remove(y);
                s2.Insert(x, x1);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityInsertRemoveAt([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int x1, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(x1 > -101 && x1 < 101);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_x1", x1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x1)", s1.IndexOf(x1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x1)", s1.LastIndexOf(x1));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(x1)", s1.Contains(x1));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                s1.Insert(x, x1);
                s1.RemoveAt(y);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2.RemoveAt(y);
                s2.Insert(x, x1);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityInsertSet([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int x1, int y, int y1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(x1 > -101 && x1 < 101);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexAssume.IsTrue(y1 > -101 && y1 < 101);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_x1", x1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x1)", s1.IndexOf(x1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x1)", s1.LastIndexOf(x1));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_y1", y1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y1)", s1.IndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y1)", s1.LastIndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(x1)", s1.Contains(x1));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y1)", s1.Contains(y1));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                s1.Insert(x, x1);
                s1[y] = y1;
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }

            try
            {
                //Second Test
                s2[y] = y1;
                s2.Insert(x, x1);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityLastIndexOfLastIndexOf([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;


            //First Test
            a1 = s1.LastIndexOf(x);
            ad1 = s1.LastIndexOf(y);


            //Second Test
            ad2 = s2.LastIndexOf(y);
            a2 = s2.LastIndexOf(x);
            //NotpAssume.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));            
            PexAssert.IsTrue(a1 == a2 && ad1 == ad2 && eq.Equals(s1, s2));

        }

        [PexMethod]
        public void PUT_CommutativityLastIndexOfRemove([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;


            //First Test
            a1 = s1.LastIndexOf(x);
            s1.Remove(y);


            //Second Test
            s2.Remove(y);
            a2 = s2.LastIndexOf(x);
            //NotpAssume.IsTrue(a1 == a2 && eq.Equals(s1, s2));            
            PexAssert.IsTrue(a1 == a2 && eq.Equals(s1, s2));

        }

        [PexMethod]
        public void PUT_CommutativityLastIndexOfRemoveAt([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                a1 = s1.LastIndexOf(x);
                s1.RemoveAt(y);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }

            try
            {
                //Second Test
                s2.RemoveAt(y);
                a2 = s2.LastIndexOf(x);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityLastIndexOfSet([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y, int y1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexAssume.IsTrue(y1 > -101 && y1 < 101);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_y1", y1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y1)", s1.IndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y1)", s1.LastIndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y1)", s1.Contains(y1));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;
            try
            {
                //First Test
                a1 = s1.LastIndexOf(x);
                s1[y] = y1;
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2[y] = y1;
                a2 = s2.LastIndexOf(x);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && a1 == a2 && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityRemoveRemove([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;


            //First Test
            s1.Remove(x);
            s1.Remove(y);


            //Second Test
            s2.Remove(y);
            s2.Remove(x);
            //NotpAssume.IsTrue(eq.Equals(s1, s2));            
            PexAssert.IsTrue(eq.Equals(s1, s2));

        }

        [PexMethod]
        public void PUT_CommutativityRemoveRemoveAt([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                s1.Remove(x);
                s1.RemoveAt(y);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2.RemoveAt(y);
                s2.Remove(x);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityRemoveSet([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y, int y1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexAssume.IsTrue(y1 > -101 && y1 < 101);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_y1", y1);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y1)", s1.IndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y1)", s1.LastIndexOf(y1));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            PexObserve.ValueForViewing("$input_s1.Contains(y1)", s1.Contains(y1));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                s1.Remove(x);
                s1[y] = y1;
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2[y] = y1;
                s2.Remove(x);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }

            //NotpAssume.IsTrue((first && second) || (!first && !second && eq.Equals(s1, s2)));
            PexAssert.IsTrue((first && second) || (!first && !second && eq.Equals(s1, s2)));

        }

        [PexMethod]
        public void PUT_CommutativityRemoveAtRemoveAt([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)", s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_s1.Contains(x)", s1.Contains(x));
            PexObserve.ValueForViewing("$input_s1.Contains(y)", s1.Contains(y));
            AssumePrecondition.IsTrue(true);

            int a1 = -1, a2 = -1;
            int ad1 = -1, ad2 = -1;
            bool first = false, second = false;

            try
            {
                //First Test
                s1.RemoveAt(x);
                s1.RemoveAt(y);
            }
            catch (ArgumentOutOfRangeException)
            {
                first = true;
            }
            try
            {
                //Second Test
                s2.RemoveAt(y);
                s2.RemoveAt(x);
            }
            catch (ArgumentOutOfRangeException)
            {
                second = true;
            }
            //NotpAssume.IsTrue((first && second) || (!first && !second && eq.Equals(s1, s2)));            
            PexAssert.IsTrue((first && second) || (!first && !second && eq.Equals(s1, s2)));

        }


        /* [PexMethod]
        public void PUT_CommutativityRemoveAtSet([PexAssumeUnderTest] DataStructures.ArrayList s1, int x, int y, int y1)
        {
            DataStructures.ArrayList s2 = new DataStructures.ArrayList(s1);
            ArrayListEqualityComparer eq = new ArrayListEqualityComparer();

            PexAssume.IsTrue(x > -11 && x < 11);
            PexAssume.IsTrue(y > -11 && y < 11);
            PexAssume.IsTrue(y1 > -101 && y1 < 101);
            PexObserve.ValueForViewing("$input_s1.Count", s1.Count);
            PexObserve.ValueForViewing("$input_x", x);
            PexObserve.ValueForViewing("$input_s1.IndexOf(x)", s1.IndexOf(x));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(x)",s1.LastIndexOf(x));
            PexObserve.ValueForViewing("$input_y", y);
            PexObserve.ValueForViewing("$input_s1.IndexOf(y)", s1.IndexOf(y));
            PexObserve.ValueForViewing("$input_s1.LastIndexOf(y)", s1.LastIndexOf(y));
            PexObserve.ValueForViewing("$input_y1", y1);*/

    }
}
       
]]></source>
</chunk>
</document>
<document src="d:\experimental3\BenchmarksAll\DataStructures\DataStructures\Utility\ArrayListEqualityComparer.cs" renderPrefix="s3"><chunk hits="-1" domain="unknown"><source><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DataStructures.Utility
{
    
    public class ArrayListEqualityComparer : EqualityComparer<ArrayList>
    {

        public override bool Equals(DataStructures.ArrayList q1, DataStructures.ArrayList q2)
        ]]></source>
</chunk>
<method name="Equals" namespace="DataStructures.Utility" type="DataStructures.Utility.ArrayListEqualityComparer" typeName="ArrayListEqualityComparer" token="6000270" module="DataStructures.dll"><hits><hit index="0" value="1"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="5" value="1"/>
<hit index="6" value="2"/>
<hit index="7" value="1"/>
<hit index="8" value="1"/>
<hit index="9" value="1"/>
<hit index="10" value="2"/>
<hit index="12" value="2"/>
<hit index="13" value="2"/>
<hit index="14" value="2"/>
<hit index="15" value="4"/>
<hit index="16" value="2"/>
<hit index="17" value="2"/>
<hit index="18" value="2"/>
<hit index="19" value="4"/>
<hit index="20" value="2"/>
<hit index="21" value="2"/>
<hit index="22" value="2"/>
<hit index="23" value="4"/>
<hit index="25" value="3"/>
<hit index="26" value="3"/>
<hit index="27" value="3"/>
<hit index="28" value="6"/>
<hit index="29" value="1"/>
<hit index="30" value="1"/>
<hit index="31" value="1"/>
<hit index="32" value="1"/>
<hit index="33" value="2"/>
<hit index="34" value="2"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="13" total="17" coveredRatio="0.76470588235294112"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            // handle null cases first
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[if (q1 == null)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="000c" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="000d" domain="usercodeundertest"><source><![CDATA[return (q2 == null);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }
            else ]]></source>
</chunk>
<chunk hits="1" offset="0014" domain="usercodeundertest"><source><![CDATA[if (q2 == null)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="001f" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                // set1 != null
                ]]></source>
</chunk>
<chunk hits="0" offset="0020" domain="usercodeundertest"><source><![CDATA[return false;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }
            else ]]></source>
</chunk>
<chunk hits="1" offset="0024" domain="usercodeundertest"><source><![CDATA[if (q1.Count != q2.Count)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0036" domain="usercodeundertest"><source><![CDATA[return false;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            for (]]></source>
</chunk>
<chunk hits="1" offset="003a" domain="usercodeundertest"><source><![CDATA[int i = 0;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="3" offset="005f" domain="usercodeundertest"><source><![CDATA[i < q1.Count]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[; ]]></source>
</chunk>
<chunk hits="2" offset="005b" domain="usercodeundertest"><source><![CDATA[i++]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[)
            ]]></source>
</chunk>
<chunk hits="2" offset="003e" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="2" offset="003f" domain="usercodeundertest"><source><![CDATA[if (!q1[i].Equals(q2[i]))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    ]]></source>
</chunk>
<chunk hits="0" offset="0056" domain="usercodeundertest"><source><![CDATA[return false;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            ]]></source>
</chunk>
<chunk hits="2" offset="005a" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="006c" domain="usercodeundertest"><source><![CDATA[return true;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0070" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        /* Angello's code: Only works for ints*/
        public override int GetHashCode(DataStructures.ArrayList q)
        {
            int hash = 0;
            for (int i = 0; i < q.Count; i++)
            {
                hash += q[i].GetHashCode();
            }

            return hash;

        }


    }
}
]]></source>
</chunk>
</document>
<document src="(no sources available for some parts of DataStructures, DataStructuresTest)" missing="true"><method name=".ctor" type="DataStructures.Utility.ArrayListEqualityComparer" token="6000272" module="DataStructures.dll"><hits/>
<coverage domain="usercodeundertest" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name=".ctor" type="DataStructures.Test.Factories.ArrayListFactory+&lt;&gt;c__DisplayClass1" token="600006a" module="DataStructuresTest.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
</document>
</documents>
